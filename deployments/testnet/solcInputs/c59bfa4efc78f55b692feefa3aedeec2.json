{
  "language": "Solidity",
  "sources": {
    "src/contracts/EligibilityManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\nimport \"./interfaces/IEligibility.sol\";\nimport \"./interfaces/IEligibilityManager.sol\";\n\ncontract EligibilityManager is IEligibilityManager, OwnableUpgradeable {\n    EligibilityModule[] public override modules;\n\n    function __EligibilityManager_init() external override initializer {\n        __Ownable_init();\n    }\n\n    function addModule(address implementation) external override onlyOwner {\n        if (implementation == address(0)) revert NoImplementation();\n\n        IEligibility elig = IEligibility(implementation);\n        string memory name = elig.name();\n        EligibilityModule memory module = EligibilityModule(\n            implementation,\n            elig.targetAsset(),\n            name\n        );\n        modules.push(module);\n        emit ModuleAdded(\n            implementation,\n            module.targetAsset,\n            name,\n            elig.finalized()\n        );\n    }\n\n    function allModules() external view override returns (EligibilityModule[] memory) {\n        return modules;\n    }\n\n    function allModuleNames() external view override returns (string[] memory) {\n        EligibilityModule[] memory modulesCopy = modules;\n        string[] memory names = new string[](modulesCopy.length);\n        for (uint256 i = 0; i < modulesCopy.length; i++) {\n            names[i] = modulesCopy[i].name;\n        }\n        return names;\n    }\n\n    function deployEligibility(uint256 moduleIndex, bytes calldata configData)\n        external\n        virtual\n        override\n        returns (address)\n    {\n        if (moduleIndex >= modules.length) revert OutOfBounds();\n        address eligImpl = modules[moduleIndex].implementation;\n        address eligibilityClone = ClonesUpgradeable.clone(eligImpl);\n        IEligibility(eligibilityClone).__Eligibility_init_bytes(\n            configData\n        );\n        return eligibilityClone;\n    }\n\n    function updateModule(uint256 moduleIndex, address implementation) external override onlyOwner {\n        if (moduleIndex >= modules.length) revert OutOfBounds();\n        if (implementation == address(0)) revert NoImplementation();\n        modules[moduleIndex].implementation = implementation;\n        IEligibility elig = IEligibility(implementation);\n        emit ModuleUpdated(implementation, elig.name(), elig.finalized());\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary ClonesUpgradeable {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "src/contracts/interfaces/IEligibility.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IEligibility {\n    // Read functions.\n    function name() external pure returns (string memory);\n\n    function finalized() external view returns (bool);\n\n    function targetAsset() external pure returns (address);\n\n    function checkAllEligible(uint256[] calldata tokenIds)\n        external\n        view\n        returns (bool);\n\n    function checkEligible(uint256[] calldata tokenIds)\n        external\n        view\n        returns (bool[] memory);\n\n    function checkAllIneligible(uint256[] calldata tokenIds)\n        external\n        view\n        returns (bool);\n\n    function checkIsEligible(uint256 tokenId) external view returns (bool);\n\n    // Write functions.\n    function __Eligibility_init_bytes(bytes calldata configData) external;\n\n    function beforeMintHook(uint256[] calldata tokenIds) external;\n\n    function afterMintHook(uint256[] calldata tokenIds) external;\n\n    function beforeRedeemHook(uint256[] calldata tokenIds) external;\n\n    function afterRedeemHook(uint256[] calldata tokenIds) external;\n}\n"
    },
    "src/contracts/interfaces/IEligibilityManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IEligibilityManager {\n    struct EligibilityModule {\n        address implementation;\n        address targetAsset;\n        string name;\n    }\n\n    function modules(uint256) external view returns(address, address, string memory);\n\n    function __EligibilityManager_init() external;\n\n    function addModule(address implementation) external;\n\n    function updateModule(uint256 moduleIndex, address implementation) external;\n\n    function deployEligibility(uint256 vaultId, bytes calldata initData) external returns (address);\n\n    function allModules() external view returns (EligibilityModule[] memory);\n\n    function allModuleNames() external view returns (string[] memory);\n\n    event ModuleAdded(\n        address implementation,\n        address targetAsset,\n        string name,\n        bool finalizedOnDeploy\n    );\n    event ModuleUpdated(\n        address implementation,\n        string name,\n        bool finalizedOnDeploy\n    );\n\n    error NoImplementation();\n    error OutOfBounds();\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = _setInitializedVersion(1);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        bool isTopLevelCall = _setInitializedVersion(version);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(version);\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        _setInitializedVersion(type(uint8).max);\n    }\n\n    function _setInitializedVersion(uint8 version) private returns (bool) {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\n        // of initializers, because in other contexts the contract may have been reentered.\n        if (_initializing) {\n            require(\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\n                \"Initializable: contract is already initialized\"\n            );\n            return false;\n        } else {\n            require(_initialized < version, \"Initializable: contract is already initialized\");\n            _initialized = version;\n            return true;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/FNFTCollection.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashBorrowerUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IPriceOracle} from \"./PriceOracle.sol\";\nimport \"./interfaces/IEligibility.sol\";\nimport \"./interfaces/IEligibilityManager.sol\";\nimport \"./interfaces/IFeeDistributor.sol\";\nimport \"./interfaces/IFNFTCollection.sol\";\nimport \"./interfaces/IFNFTCollectionFactory.sol\";\nimport \"./interfaces/IPausable.sol\";\nimport \"./interfaces/IVaultManager.sol\";\nimport \"./token/ERC20FlashMintUpgradeable.sol\";\n\n// Authors: @0xKiwi_ and @alexgausman.\n\ncontract FNFTCollection is\n    IFNFTCollection,\n    OwnableUpgradeable,\n    IERC165,\n    ERC20FlashMintUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC721HolderUpgradeable,\n    ERC1155HolderUpgradeable\n{\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n    uint256 public constant BASE = 10**18;\n\n    mapping(uint256 => uint256) public override quantity1155;\n    EnumerableSetUpgradeable.UintSet internal holdings;\n\n    IEligibility public override eligibilityStorage;\n    IFNFTCollectionFactory public override factory;\n    IVaultManager public override vaultManager;\n    address public override curator;\n\n    uint256 public override vaultId;\n    uint256 private randNonce;\n\n    /// @notice the length of auctions\n    uint256 public override auctionLength;\n\n    address public override assetAddress;\n    bool public override is1155;\n    bool public override allowAllItems;\n    bool public override enableMint;\n    bool public override enableRandomRedeem;\n    bool public override enableTargetRedeem;\n    bool public override enableRandomSwap;\n    bool public override enableTargetSwap;\n    bool public override enableBid;\n\n    /// @notice only used for ERC-721 tokens\n    mapping (uint256 => address) public depositors;\n    mapping (uint256 => Auction) public auctions;\n\n    function __FNFTCollection_init(\n        string memory _name,\n        string memory _symbol,\n        address _curator,\n        address _assetAddress,\n        bool _is1155,\n        bool _allowAllItems\n    ) external override virtual initializer {\n        __Ownable_init();\n        __ERC20_init(_name, _symbol);\n        if (_assetAddress == address(0)) revert ZeroAddress();\n        setVaultFeatures(true /*enableMint*/, true /*enableRandomRedeem*/, true /*enableTargetRedeem*/, true /*enableRandomSwap*/, true /*enableTargetSwap*/, false /*enableBid*/);\n        IFNFTCollectionFactory _factory = IFNFTCollectionFactory(msg.sender);\n        vaultManager = IVaultManager(_factory.vaultManager());\n        assetAddress = _assetAddress;\n        curator = _curator;\n        factory = _factory;\n        vaultId = vaultManager.numVaults();\n        is1155 = _is1155;\n        allowAllItems = _allowAllItems;\n        auctionLength = 3 days;\n        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);\n    }\n\n    function allHoldings() external view override virtual returns (uint256[] memory) {\n        uint256 len = holdings.length();\n        uint256[] memory idArray = new uint256[](len);\n        for (uint256 i; i < len;) {\n            idArray[i] = holdings.at(i);\n            unchecked {\n                ++i;\n            }\n        }\n        return idArray;\n    }\n\n    // This function allows for an easy setup of any eligibility module contract from the EligibilityManager.\n    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow\n    // a similar interface.\n    function deployEligibilityStorage(\n        uint256 moduleIndex,\n        bytes calldata initData\n    ) external override virtual returns (address) {\n        _onlyPrivileged();\n        if (address(eligibilityStorage) != address(0)) revert EligibilityAlreadySet();\n        IEligibilityManager eligManager = IEligibilityManager(\n            factory.eligibilityManager()\n        );\n        address _eligibility = eligManager.deployEligibility(\n            moduleIndex,\n            initData\n        );\n        eligibilityStorage = IEligibility(_eligibility);\n        // Toggle this to let the contract know to check eligibility now.\n        allowAllItems = false;\n        emit EligibilityDeployed(moduleIndex, _eligibility);\n        return _eligibility;\n    }\n\n    function finalizeVault() external override virtual {\n        setCurator(address(0));\n    }\n\n    function mint(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts /* ignored for ERC721 vaults */\n    ) external override virtual returns (uint256) {\n        return mintTo(tokenIds, amounts, msg.sender);\n    }\n\n    function nftIdAt(uint256 holdingsIndex) external view override virtual returns (uint256) {\n        return holdings.at(holdingsIndex);\n    }\n\n    function redeem(uint256 amount, uint256[] calldata specificIds)\n        external\n        override\n        virtual\n        returns (uint256[] memory)\n    {\n        return redeemTo(amount, specificIds, msg.sender);\n    }\n\n    function withdraw(uint256[] calldata tokenIds) external override virtual returns (uint256[] memory) {\n        _onlyOwnerIfPaused(2);\n        if (!enableBid) revert BidDisabled();\n\n        uint256 amount = tokenIds.length;\n\n        for (uint256 i; i < amount;) {\n            uint256 tokenId = tokenIds[i];\n            if (depositors[tokenId] != msg.sender) revert NotNFTOwner();\n            unchecked {\n                ++i;\n            }\n        }\n\n        // We burn all from sender and mint to fee receiver to reduce costs.\n        _burn(msg.sender, BASE * amount);\n\n        // Pay the tokens + toll.\n        (,, uint256 _targetRedeemFee,,) = vaultFees();\n        uint256 totalFee = _targetRedeemFee * amount;\n        _chargeAndDistributeFees(msg.sender, totalFee);\n\n        // Withdraw from vault.\n        uint256[] memory redeemedIds = _withdrawNFTsTo(amount, tokenIds, msg.sender);\n        emit Redeemed(redeemedIds, tokenIds, msg.sender);\n        return redeemedIds;\n    }\n\n    function setVaultMetadata(\n        string calldata name_,\n        string calldata symbol_\n    ) external override virtual {\n        _onlyPrivileged();\n        _setMetadata(name_, symbol_);\n    }\n\n    function swap(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n        uint256[] calldata specificIds\n    ) external override virtual returns (uint256[] memory) {\n        return swapTo(tokenIds, amounts, specificIds, msg.sender);\n    }\n\n    function totalHoldings() external view override virtual returns (uint256) {\n        return holdings.length();\n    }\n\n    function version() external pure override returns (string memory) {\n        return \"v1.0.0\";\n    }\n\n    function allValidNFTs(uint256[] memory tokenIds)\n        public\n        view\n        override\n        virtual\n        returns (bool)\n    {\n        if (allowAllItems) {\n            return true;\n        }\n\n        IEligibility _eligibilityStorage = eligibilityStorage;\n        if (address(_eligibilityStorage) == address(0)) {\n            return false;\n        }\n        return _eligibilityStorage.checkAllEligible(tokenIds);\n    }\n\n    function retrieveTokens(uint256 amount, address from, address to) public onlyOwner {\n        _burn(from, amount);\n        _mint(to, amount);\n    }\n\n    function disableVaultFees() public override virtual {\n        _onlyPrivileged();\n        factory.disableVaultFees(vaultId);\n    }\n\n    function flashFee(address borrowedToken, uint256 amount) public view override (\n        IERC3156FlashLenderUpgradeable,\n        IFNFTCollection\n    ) returns (uint256) {\n        if (borrowedToken != address(this)) revert InvalidToken();\n        return factory.flashLoanFee() * amount / 10000;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrowerUpgradeable receiver,\n        address borrowedToken,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override (\n        IERC3156FlashLenderUpgradeable,\n        IFNFTCollection\n    ) returns (bool) {\n        _onlyOwnerIfPaused(5);\n\n        uint256 flashLoanFee = vaultManager.excludedFromFees(address(receiver)) ? 0 : flashFee(borrowedToken, amount);\n        return _flashLoan(receiver, borrowedToken, amount, flashLoanFee, data);\n    }\n\n    function mintFee() public view override virtual returns (uint256) {\n        (uint256 _mintFee, , , ,) = factory.vaultFees(vaultId);\n        return _mintFee;\n    }\n\n    function mintTo(\n        uint256[] memory tokenIds,\n        uint256[] memory amounts, /* ignored for ERC721 vaults */\n        address to\n    ) public override virtual nonReentrant returns (uint256) {\n        _onlyOwnerIfPaused(1);\n        if (!enableMint) revert MintDisabled();\n        // Take the NFTs.\n        uint256 count = _receiveNFTs(tokenIds, amounts);\n\n        // Mint to the user.\n        _mint(to, BASE * count);\n        uint256 totalFee = mintFee() * count;\n        _chargeAndDistributeFees(to, totalFee);\n\n        emit Minted(tokenIds, amounts, to);\n        return count;\n    }\n\n    function randomRedeemFee() public view override virtual returns (uint256) {\n        (, uint256 _randomRedeemFee, , ,) = factory.vaultFees(vaultId);\n        return _randomRedeemFee;\n    }\n\n    function randomSwapFee() public view override virtual returns (uint256) {\n        (, , , uint256 _randomSwapFee, ) = factory.vaultFees(vaultId);\n        return _randomSwapFee;\n    }\n\n    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)\n        public\n        override\n        virtual\n        nonReentrant\n        returns (uint256[] memory)\n    {\n        _onlyOwnerIfPaused(2);\n        if (enableBid) revert BidEnabled();\n        if (amount != specificIds.length && !enableRandomRedeem) revert RandomRedeemDisabled();\n        if (specificIds.length != 0 && !enableTargetRedeem) revert TargetRedeemDisabled();\n\n        // We burn all from sender and mint to fee receiver to reduce costs.\n        _burn(msg.sender, BASE * amount);\n\n        // Pay the tokens + toll.\n        (, uint256 _randomRedeemFee, uint256 _targetRedeemFee, ,) = vaultFees();\n        uint256 totalFee = (_targetRedeemFee * specificIds.length) + (\n            _randomRedeemFee * (amount - specificIds.length)\n        );\n        _chargeAndDistributeFees(msg.sender, totalFee);\n\n        // Withdraw from vault.\n        uint256[] memory redeemedIds = _withdrawNFTsTo(amount, specificIds, to);\n        emit Redeemed(redeemedIds, specificIds, to);\n        return redeemedIds;\n    }\n\n    function setFees(\n        uint256 _mintFee,\n        uint256 _randomRedeemFee,\n        uint256 _targetRedeemFee,\n        uint256 _randomSwapFee,\n        uint256 _targetSwapFee\n    ) public override virtual {\n        _onlyPrivileged();\n        factory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);\n    }\n\n    // The curator has control over options like fees and features\n    function setCurator(address _curator) public override virtual {\n        _onlyPrivileged();\n        if (curator == _curator) revert SameCurator();\n        emit CuratorUpdated(curator, _curator);\n        curator = _curator;\n    }\n\n    function setVaultFeatures(\n        bool _enableMint,\n        bool _enableRandomRedeem,\n        bool _enableTargetRedeem,\n        bool _enableRandomSwap,\n        bool _enableTargetSwap,\n        bool _enableBid\n    ) public override virtual {\n        _onlyPrivileged();\n        enableMint = _enableMint;\n        enableRandomRedeem = _enableRandomRedeem;\n        enableTargetRedeem = _enableTargetRedeem;\n        enableRandomSwap = _enableRandomSwap;\n        enableTargetSwap = _enableTargetSwap;\n        enableBid = _enableBid;\n\n        emit VaultFeaturesUpdated(\n            _enableMint,\n            _enableRandomRedeem,\n            _enableTargetRedeem,\n            _enableRandomSwap,\n            _enableTargetSwap,\n            _enableBid\n        );\n    }\n\n    /// @notice allow curator to update the auction length\n    /// @param _auctionLength the new base price\n    function setAuctionLength(uint256 _auctionLength) external override {\n        _onlyPrivileged();\n        if (\n            _auctionLength < factory.minAuctionLength() || _auctionLength > factory.maxAuctionLength()\n        ) revert InvalidAuctionLength();\n\n        auctionLength = _auctionLength;\n        emit AuctionLengthUpdated(_auctionLength);\n    }\n\n    function shutdown(address recipient) public override onlyOwner {\n        uint256 numItems = totalSupply() / BASE;\n        if (numItems >= 4) revert TooManyNFTs();\n        uint256[] memory specificIds = new uint256[](0);\n        _withdrawNFTsTo(numItems, specificIds, recipient);\n        emit VaultShutdown(assetAddress, numItems, recipient);\n        assetAddress = address(0);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC1155ReceiverUpgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IFNFTCollection).interfaceId ||\n                interfaceId == type(IERC165).interfaceId ||\n                super.supportsInterface(interfaceId);\n    }\n\n    function swapTo(\n        uint256[] memory tokenIds,\n        uint256[] memory amounts, /* ignored for ERC721 vaults */\n        uint256[] memory specificIds,\n        address to\n    ) public override virtual nonReentrant returns (uint256[] memory) {\n        _onlyOwnerIfPaused(3);\n        if (enableBid) revert BidEnabled();\n\n        uint256 count;\n        if (is1155) {\n            for (uint256 i; i < tokenIds.length;) {\n                uint256 amount = amounts[i];\n                if (amount == 0) revert ZeroTransferAmount();\n                count += amount;\n                unchecked {\n                    ++i;\n                }\n            }\n        } else {\n            count = tokenIds.length;\n        }\n\n        if (count != specificIds.length && !enableRandomSwap) revert RandomSwapDisabled();\n        if (specificIds.length != 0 && !enableTargetSwap) revert TargetSwapDisabled();\n\n        (, , ,uint256 _randomSwapFee, uint256 _targetSwapFee) = vaultFees();\n        uint256 totalFee = (_targetSwapFee * specificIds.length) + (\n            _randomSwapFee * (count - specificIds.length)\n        );\n        _chargeAndDistributeFees(msg.sender, totalFee);\n\n        // Give the NFTs first, so the user wont get the same thing back, just to be nice.\n        uint256[] memory ids = _withdrawNFTsTo(count, specificIds, to);\n\n        _receiveNFTs(tokenIds, amounts);\n\n        emit Swapped(tokenIds, amounts, specificIds, ids, to);\n        return ids;\n    }\n\n    function startAuction(uint256 tokenId, uint256 price) external override {\n        _onlyOwnerIfPaused(4);\n        if (!enableBid || is1155) revert BidDisabled();\n        if (auctions[tokenId].state != AuctionState.Inactive) revert AuctionLive();\n        if (price < BASE) revert BidTooLow();\n\n        _burn(msg.sender, price);\n\n        auctions[tokenId] = Auction({\n            livePrice: price,\n            end: block.timestamp + auctionLength,\n            state: AuctionState.Live,\n            winning: msg.sender\n        });\n\n        emit AuctionStarted(msg.sender, tokenId, price);\n    }\n\n    function bid(uint256 tokenId, uint256 price) external override {\n        _onlyOwnerIfPaused(4);\n        if (!enableBid || is1155) revert BidDisabled();\n        if (auctions[tokenId].state != AuctionState.Live) revert AuctionNotLive();\n        uint256 livePrice = auctions[tokenId].livePrice;\n        uint256 increase = factory.minBidIncrease() + 10000;\n        if (price * 10000 < livePrice * increase) revert BidTooLow();\n\n        uint256 auctionEnd = auctions[tokenId].end;\n        if (block.timestamp >= auctionEnd) revert AuctionEnded();\n\n        _burn(msg.sender, price);\n        _mint(auctions[tokenId].winning, livePrice);\n\n        auctions[tokenId].livePrice = price;\n        auctions[tokenId].winning = msg.sender;\n\n        if (auctionEnd - block.timestamp <= 15 minutes) {\n            auctions[tokenId].end += 15 minutes;\n        }\n\n        emit BidMade(msg.sender, tokenId, price);\n    }\n\n    function endAuction(uint256 tokenId) external override {\n        _onlyOwnerIfPaused(4);\n        if (!enableBid || is1155) revert BidDisabled();\n        if (auctions[tokenId].state != AuctionState.Live) revert AuctionNotLive();\n        if (block.timestamp < auctions[tokenId].end) revert AuctionNotEnded();\n\n        address winner = auctions[tokenId].winning;\n        uint256 price = auctions[tokenId].livePrice;\n\n        auctions[tokenId].livePrice = 0;\n        auctions[tokenId].end = 0;\n        auctions[tokenId].state = AuctionState.Inactive;\n        auctions[tokenId].winning = address(0);\n\n        uint256 premium = price - BASE;\n        if (premium > 0) _mint(depositors[tokenId], premium);\n\n        uint256[] memory withdrawTokenIds = new uint256[](1);\n        withdrawTokenIds[0] = tokenId;\n        _withdrawNFTsTo(1, withdrawTokenIds, winner);\n\n        emit AuctionWon(winner, tokenId, price);\n    }\n\n    function getAuction(uint256 tokenId) external view override returns (uint256, uint256, AuctionState, address) {\n        AuctionState state = auctions[tokenId].state;\n        if (state == AuctionState.Inactive) revert AuctionNotLive();\n\n        return (\n            auctions[tokenId].livePrice,\n            auctions[tokenId].end,\n            state,\n            auctions[tokenId].winning\n        );\n    }\n\n    function getDepositor(uint256 tokenId) external view override returns (address depositor) {\n        depositor = depositors[tokenId];\n        if (depositor == address(0)) revert NotInVault();\n    }\n\n    function targetRedeemFee() public view override virtual returns (uint256) {\n        (, , uint256 _targetRedeemFee, ,) = factory.vaultFees(vaultId);\n        return _targetRedeemFee;\n    }\n\n    function targetSwapFee() public view override virtual returns (uint256) {\n        (, , , ,uint256 _targetSwapFee) = factory.vaultFees(vaultId);\n        return _targetSwapFee;\n    }\n\n    function vaultFees() public view override virtual returns (uint256, uint256, uint256, uint256, uint256) {\n        return factory.vaultFees(vaultId);\n    }\n\n    // We set a hook to the eligibility module (if it exists) after redeems in case anything needs to be modified.\n    function _afterRedeemHook(uint256[] memory tokenIds) internal virtual {\n        IEligibility _eligibilityStorage = eligibilityStorage;\n        if (address(_eligibilityStorage) == address(0)) {\n            return;\n        }\n        _eligibilityStorage.afterRedeemHook(tokenIds);\n    }\n\n    function _afterTokenTransfer(\n        address,\n        address,\n        uint256\n    ) internal virtual override {\n        address priceOracle = vaultManager.priceOracle();\n        if (priceOracle != address(0)) {\n            IPriceOracle(priceOracle).updateFNFTPairInfo(address(this));\n        }\n    }\n\n    function _chargeAndDistributeFees(address user, uint256 amount) internal override virtual {\n        if (amount == 0) {\n            return;\n        }\n\n        IVaultManager _vaultManager = vaultManager;\n\n        if (_vaultManager.excludedFromFees(msg.sender)) {\n            return;\n        }\n\n        // Mint fees directly to the distributor and distribute.\n        address feeDistributor = _vaultManager.feeDistributor();\n        // Changed to a _transfer() in v1.0.3.\n        super._transfer(user, feeDistributor, amount);\n        IFeeDistributor(feeDistributor).distribute(vaultId);\n    }\n\n    function _getRandomTokenIdFromVault() internal virtual returns (uint256) {\n        uint256 randomIndex = uint256(\n            keccak256(\n                abi.encodePacked(\n                    blockhash(block.number - 1),\n                    randNonce,\n                    block.coinbase,\n                    block.difficulty,\n                    block.timestamp\n                )\n            )\n        ) % holdings.length();\n        ++randNonce;\n        return holdings.at(randomIndex);\n    }\n\n    function _receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)\n        internal\n        virtual\n        returns (uint256)\n    {\n        if (!allValidNFTs(tokenIds)) revert IneligibleNFTs();\n        uint256 length = tokenIds.length;\n        if (is1155) {\n            // This is technically a check, so placing it before the effect.\n            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(\n                msg.sender,\n                address(this),\n                tokenIds,\n                amounts,\n                \"\"\n            );\n\n            uint256 count;\n            for (uint256 i; i < length;) {\n                uint256 tokenId = tokenIds[i];\n                uint256 amount = amounts[i];\n                if (amount == 0) revert ZeroTransferAmount();\n                if (quantity1155[tokenId] == 0) {\n                    holdings.add(tokenId);\n                }\n                quantity1155[tokenId] += amount;\n                count += amount;\n                unchecked {\n                    ++i;\n                }\n            }\n            return count;\n        } else {\n            address _assetAddress = assetAddress;\n            for (uint256 i; i < length;) {\n                uint256 tokenId = tokenIds[i];\n                // We may already own the NFT here so we check in order:\n                // Does the vault own it?\n                //   - If so, check if its in holdings list\n                //      - If so, we reject. This means the NFT has already been claimed for.\n                //      - If not, it means we have not yet accounted for this NFT, so we continue.\n                //   -If not, we \"pull\" it from the msg.sender and add to holdings.\n                _transferFromERC721(_assetAddress, tokenId);\n                depositors[tokenId] = msg.sender;\n                holdings.add(tokenId);\n                unchecked {\n                    ++i;\n                }\n            }\n            return length;\n        }\n    }\n\n    function _onlyOwnerIfPaused(uint256 lockId) internal view {\n        if (msg.sender != owner() && IPausable(address(factory)).isPaused(lockId)) revert Paused();\n    }\n\n\n    function _onlyPrivileged() internal view {\n        if (curator == address(0)) {\n            if (msg.sender != owner()) revert NotOwner();\n        } else {\n            if (msg.sender != curator) revert NotCurator();\n        }\n    }\n\n    function _transferERC721(address assetAddr, address to, uint256 tokenId) internal virtual {\n        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n        bytes memory data;\n        if (assetAddr == kitties) {\n            // Changed in v1.0.4.\n            data = abi.encodeWithSignature(\"transfer(address,uint256)\", to, tokenId);\n        } else if (assetAddr == punks) {\n            // CryptoPunks.\n            data = abi.encodeWithSignature(\"transferPunk(address,uint256)\", to, tokenId);\n        } else {\n            // Default.\n            data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", address(this), to, tokenId);\n        }\n        (bool success, bytes memory returnData) = address(assetAddr).call(data);\n        require(success, string(returnData));\n    }\n\n    function _transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {\n        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n        bytes memory data;\n        if (assetAddr == kitties) {\n            // Cryptokitties.\n            data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n        } else if (assetAddr == punks) {\n            // CryptoPunks.\n            // Fix here for frontrun attack. Added in v1.0.2.\n            bytes memory punkIndexToAddress = abi.encodeWithSignature(\"punkIndexToAddress(uint256)\", tokenId);\n            (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);\n            (address nftOwner) = abi.decode(result, (address));\n            if (!checkSuccess || nftOwner != msg.sender) revert NotNFTOwner();\n            data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenId);\n        } else {\n            // Default.\n            // Allow other contracts to \"push\" into the vault, safely.\n            // If we already have the token requested, make sure we don't have it in the list to prevent duplicate minting.\n            if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) {\n                if (holdings.contains(tokenId)) revert NFTAlreadyInCollection();\n                return;\n            } else {\n                data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n            }\n        }\n        (bool success, bytes memory resultData) = address(assetAddr).call(data);\n        require(success, string(resultData));\n    }\n\n    function _withdrawNFTsTo(\n        uint256 amount,\n        uint256[] memory specificIds,\n        address to\n    ) internal virtual returns (uint256[] memory) {\n        bool _is1155 = is1155;\n        address _assetAddress = assetAddress;\n        uint256[] memory redeemedIds = new uint256[](amount);\n        uint256 specificLength = specificIds.length;\n        for (uint256 i; i < amount;) {\n            // This will always be fine considering the validations made above.\n            uint256 tokenId = i < specificLength ?\n                specificIds[i] : _getRandomTokenIdFromVault();\n            redeemedIds[i] = tokenId;\n\n            if (_is1155) {\n                quantity1155[tokenId] -= 1;\n                if (quantity1155[tokenId] == 0) {\n                    holdings.remove(tokenId);\n                }\n\n                IERC1155Upgradeable(_assetAddress).safeTransferFrom(\n                    address(this),\n                    to,\n                    tokenId,\n                    1,\n                    \"\"\n                );\n            } else {\n                holdings.remove(tokenId);\n                delete depositors[tokenId];\n                _transferERC721(_assetAddress, to, tokenId);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        _afterRedeemHook(redeemedIds);\n        return redeemedIds;\n    }\n}"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashBorrowerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashBorrower.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC3156 FlashBorrower, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashBorrowerUpgradeable {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721ReceiverUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {\n    function __ERC721Holder_init() internal onlyInitializing {\n    }\n\n    function __ERC721Holder_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155ReceiverUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155HolderUpgradeable is Initializable, ERC1155ReceiverUpgradeable {\n    function __ERC1155Holder_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Holder_init_unchained() internal onlyInitializing {\n    }\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/contracts/PriceOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\nimport \"./interfaces/IUniswapV2Factory.sol\";\nimport \"./libraries/PriceOracleLibrary.sol\";\nimport \"./libraries/UQ112x112.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\n\n/**\n    1. Store cumulative prices for each pair in the pool\n    2. Update to calculate twap and update for each pair\n*/\ncontract PriceOracle is IPriceOracle, OwnableUpgradeable {\n    using FixedPoint for *;\n\n    IUniswapV2Factory public immutable override factory;\n    address public immutable override WETH;\n\n    // Map of pair address to PairInfo struct, which contains cumulative price, last block timestamps, and etc.\n    mapping(address => PairInfo) private _getTwap;\n\n    uint256 public override minimumPairInfoUpdate;\n    uint256 public override period;\n\n    constructor(address _factory, address _weth) {\n        factory = IUniswapV2Factory(_factory);\n        WETH = _weth;\n    }\n\n    function __PriceOracle_init() external override initializer {\n        __Ownable_init();\n\n        period = 10 minutes;\n        minimumPairInfoUpdate = 10;\n    }\n\n    // Get TWAP price of a token.\n    function consult(\n        address _token,\n        address _pair,\n        uint256 _amountIn\n    ) external view override returns (uint256 amountOut) {\n        PairInfo memory pairInfo = _getTwap[_pair];\n        if (!pairInfo.exists) revert PairInfoDoesNotExist();\n\n        amountOut = _calculatePrice(_token, _amountIn, pairInfo);\n    }\n\n    function createFNFTPair(address _token0) external override returns (address) {\n        return _createPairAddress(_token0, WETH);\n    }\n\n    // Get FNFT TWAP Price in ETH/WETH.\n    // note this will always return 0 before update has been called successfully for the first time.\n    function getFNFTPriceETH(address _fnft, uint256 _amountIn) external view override returns (uint256 amountOut) {\n        address pair = _getPairAddress(_fnft, WETH);\n        PairInfo memory pairInfo = _getTwap[pair];\n        if (!pairInfo.exists) revert PairInfoDoesNotExist();\n        if (pairInfo.totalUpdates < minimumPairInfoUpdate) revert NotEnoughUpdates();\n\n        amountOut = _calculatePrice(_fnft, _amountIn, pairInfo);\n    }\n\n    // Get pair address from factory. Returns address(0) if not found.\n    function getPairAddress(address _token0, address _token1) external view override returns (address) {\n        return _getPairAddress(_token0, _token1);\n    }\n\n    // Get pair info with uniswap v2 pair address.\n    function getPairInfo(address _pair) external view override returns (PairInfo memory pairInfo) {\n        pairInfo = _getTwap[_pair];\n    }\n\n    // Get pair info, which includes cumulative prices, last block timestamp, price average, and etc.\n    function getPairInfo(address _token0, address _token1) external view override returns (PairInfo memory pairInfo) {\n        address pairAddress = _getPairAddress(_token0, _token1);\n        pairInfo = _getTwap[pairAddress];\n    }\n\n    // Set minimum pair info info update required to get FNFT-WETH TWAP price.\n    function setMinimumPairInfoUpdate(uint256 _minimumPairInfoUpdate) external override onlyOwner {\n        emit MinimumPairInfoUpdateUpdated(minimumPairInfoUpdate, _minimumPairInfoUpdate);\n        minimumPairInfoUpdate = _minimumPairInfoUpdate;\n    }\n\n    // Set minimum period to wait for the next pair info update.\n    function setPeriod(uint256 _period) external override onlyOwner {\n        emit PeriodUpdated(period, _period);\n        period = _period;\n    }\n\n    // Update FNFT-WETH pair info.\n    function updateFNFTPairInfo(address _fnft) external override {\n        _updatePairInfo(_fnft, WETH);\n    }\n\n    // Update pair info.\n    function updatePairInfo(address _token0, address _token1) external override {\n        _updatePairInfo(_token0, _token1);\n    }\n\n    // Add pair info to price oracle.\n    function _addPairInfo(address _token0, address _token1) internal {\n        // Get predetermined pair address.\n        address pairAddress = _getPairAddress(_token0, _token1);\n        PairInfo storage pairInfo = _getTwap[pairAddress];\n        if (pairInfo.exists) revert PairInfoAlreadyExists();\n\n        // Get pair information for the given pair address.\n        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\n\n        // Get last block timestamp from reserves.\n        (, , uint32 blockTimestampLast) = pair.getReserves();\n\n        // Initialize pairInfo for the two tokens.\n        pairInfo.token0 = pair.token0();\n        pairInfo.token1 = pair.token1();\n        pairInfo.price0CumulativeLast = pair.price0CumulativeLast(); // fetch the current accumulated price value (token1 / token0)\n        pairInfo.price1CumulativeLast = pair.price1CumulativeLast(); // fetch the current accumulated price value (token0 / token1)\n        pairInfo.blockTimestampLast = blockTimestampLast;\n        pairInfo.exists = true;\n    }\n\n    // Calculate token twap price based on pair info and the amount in.\n    function _calculatePrice(address _token, uint256 _amountIn, PairInfo memory _pairInfo) internal pure returns (uint256 amountOut) {\n        if (_token == _pairInfo.token0) {\n            amountOut = _pairInfo.price0Average.mul(_amountIn).decode144();\n        } else {\n            if (_token != _pairInfo.token1) revert InvalidToken();\n            amountOut = _pairInfo.price1Average.mul(_amountIn).decode144();\n        }\n    }\n\n    // Create pair address from uniswap pair factory.\n    function _createPairAddress(address _token0, address _token1) internal returns (address) {\n        return factory.createPair(_token0, _token1);\n    }\n\n    // Get pair address from uniswap pair factory.\n    function _getPairAddress(address _token0, address _token1) internal view returns (address) {\n        return factory.getPair(_token0, _token1);\n    }\n\n    // Update pair info of two token pair.\n    function _updatePairInfo(address _token0, address _token1) internal {\n        // Get predetermined pair address.\n        address pairAddress = _getPairAddress(_token0, _token1);\n        // Update or add pair info if the pair has been created from factory.\n        if (pairAddress != address(0)){\n            PairInfo storage pairInfo = _getTwap[pairAddress];\n            // we want an update to silently skip because it's updated from the token contract itself\n            if (pairInfo.exists) {\n                // Get cumulative prices for each token pairs and block timestampe in the pool.\n                (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = PriceOracleLibrary\n                    .currentCumulativePrices(pairAddress);\n                if (price0Cumulative != 0 && price1Cumulative != 0) {\n                    uint32 timeElapsed = blockTimestamp - pairInfo.blockTimestampLast;\n                    if (timeElapsed >= period) {\n                        // Overflow is desired, casting never truncates.\n                        // Cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by the time elapsed.\n                        FixedPoint.uq112x112 memory price0Average = FixedPoint.uq112x112(\n                            uint224((price0Cumulative - pairInfo.price0CumulativeLast) / timeElapsed)\n                        );\n                        FixedPoint.uq112x112 memory price1Average = FixedPoint.uq112x112(\n                            uint224((price1Cumulative - pairInfo.price1CumulativeLast) / timeElapsed)\n                        );\n                        pairInfo.price0Average = price0Average;\n                        pairInfo.price1Average = price1Average;\n                        pairInfo.price0CumulativeLast = price0Cumulative;\n                        pairInfo.price1CumulativeLast = price1Cumulative;\n                        pairInfo.blockTimestampLast = blockTimestamp;\n                        ++pairInfo.totalUpdates;\n                    }\n                }\n            } else {\n                _addPairInfo(_token0, _token1);\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/interfaces/IFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./IVaultManager.sol\";\nimport \"./ILPStaking.sol\";\nimport \"./IFNFTStaking.sol\";\n\ninterface IFeeDistributor {\n\n  struct FeeReceiver {\n    uint256 allocPoint;\n    address receiver;\n    bool isContract;\n  }\n\n  function distributionPaused() external returns (bool);\n\n  function vaultManager() external returns (IVaultManager);\n\n  function lpStaking() external returns (ILPStaking);\n\n  function fnftStaking() external returns (IFNFTStaking);\n\n  function treasury() external returns (address);\n\n  function allocTotal() external returns (uint256);\n\n  function feeReceivers(uint256) external returns (uint256, address, bool);\n\n  function __FeeDistributor_init(address _vaultManager, address _lpStaking, address _treasury) external;\n\n  function rescueTokens(address token) external;\n\n  function distribute(uint256 vaultId) external;\n\n  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external;\n\n  function initializeVaultReceivers(uint256 _vaultId) external;\n\n  function changeReceiverAlloc(uint256 _idx, uint256 _allocPoint) external;\n\n  function changeReceiverAddress(uint256 _idx, address _address, bool _isContract) external;\n\n  function removeReceiver(uint256 _receiverIdx) external;\n\n  function setTreasuryAddress(address _treasury) external;\n\n  function setLPStakingAddress(address _lpStaking) external;\n\n  function setFNFTStakingAddress(address _inventoryStaking) external;\n\n  function pauseFeeDistribution(bool _pause) external;\n\n  event TreasuryAddressUpdated(address newTreasury);\n  event LPStakingAddressUpdated(address newLPStaking);\n  event FNFTStakingAddressUpdated(address newFNFTStaking);\n  event DistributionPaused(bool paused);\n  event FeeReceiverAdded(address receiver, uint256 allocPoint);\n  event FeeReceiverAllocUpdated(address receiver, uint256 allocPoint);\n  event FeeReceiverAddressUpdated(address oldReceiver, address newReceiver);\n  event FeeReceiverRemoved(address receiver);\n\n  error NotVaultManager();\n  error OutOfBounds();\n  error ZeroAddress();\n}"
    },
    "src/contracts/interfaces/IFNFTCollection.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashBorrowerUpgradeable.sol\";\n\nimport \"./IEligibility.sol\";\nimport \"./IFNFTCollectionFactory.sol\";\nimport \"./IVaultManager.sol\";\nimport \"../token/ERC20Upgradeable.sol\";\n\ninterface IFNFTCollection is IERC20Upgradeable {\n    enum AuctionState { Inactive, Live, Ended }\n\n    struct Auction {\n        uint256 livePrice;\n        uint256 end;\n        AuctionState state;\n        address winning;\n    }\n\n    function vaultManager() external view returns (IVaultManager);\n\n    function curator() external view returns (address);\n\n    function assetAddress() external view returns (address);\n\n    function factory() external view returns (IFNFTCollectionFactory);\n\n    function eligibilityStorage() external view returns (IEligibility);\n\n    function is1155() external view returns (bool);\n\n    function allowAllItems() external view returns (bool);\n\n    function enableMint() external view returns (bool);\n\n    function enableRandomRedeem() external view returns (bool);\n\n    function enableTargetRedeem() external view returns (bool);\n\n    function enableRandomSwap() external view returns (bool);\n\n    function enableTargetSwap() external view returns (bool);\n\n    function enableBid() external view returns (bool);\n\n    function auctionLength() external view returns (uint256);\n\n    function quantity1155(uint256) external view returns (uint256);\n\n    function vaultId() external view returns (uint256);\n\n    function nftIdAt(uint256 holdingsIndex) external view returns (uint256);\n\n    function allHoldings() external view returns (uint256[] memory);\n\n    function totalHoldings() external view returns (uint256);\n\n    function mintFee() external view returns (uint256);\n\n    function randomRedeemFee() external view returns (uint256);\n\n    function targetRedeemFee() external view returns (uint256);\n\n    function randomSwapFee() external view returns (uint256);\n\n    function targetSwapFee() external view returns (uint256);\n\n    function vaultFees() external view returns (uint256, uint256, uint256, uint256, uint256);\n\n    function shutdown(address recipient) external;\n\n    function version() external returns (string memory);\n\n    function __FNFTCollection_init(\n        string calldata _name,\n        string calldata _symbol,\n        address _curator,\n        address _assetAddress,\n        bool _is1155,\n        bool _allowAllItems\n    ) external;\n\n    function finalizeVault() external;\n\n    function setVaultMetadata(\n        string calldata name_,\n        string calldata symbol_\n    ) external;\n\n    function setVaultFeatures(\n        bool _enableMint,\n        bool _enableRandomRedeem,\n        bool _enableTargetRedeem,\n        bool _enableRandomSwap,\n        bool _enableTargetSwap,\n        bool _enableBid\n    ) external;\n\n    function setFees(\n        uint256 _mintFee,\n        uint256 _randomRedeemFee,\n        uint256 _targetRedeemFee,\n        uint256 _randomSwapFee,\n        uint256 _targetSwapFee\n    ) external;\n\n    function setAuctionLength(uint256 _auctionLength) external;\n\n    function disableVaultFees() external;\n\n    // This function allows for an easy setup of any eligibility module contract from the EligibilityManager.\n    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow\n    // a similar interface.\n    function deployEligibilityStorage(\n        uint256 moduleIndex,\n        bytes calldata initData\n    ) external returns (address);\n\n    // The curator has control over options like fees and features\n    function setCurator(address _curator) external;\n\n    function mint(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts /* ignored for ERC721 vaults */\n    ) external returns (uint256);\n\n    function mintTo(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n        address to\n    ) external returns (uint256);\n\n    function redeem(uint256 amount, uint256[] calldata specificIds)\n        external\n        returns (uint256[] calldata);\n\n    function redeemTo(\n        uint256 amount,\n        uint256[] calldata specificIds,\n        address to\n    ) external returns (uint256[] calldata);\n\n    function swap(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n        uint256[] calldata specificIds\n    ) external returns (uint256[] calldata);\n\n    function swapTo(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n        uint256[] calldata specificIds,\n        address to\n    ) external returns (uint256[] calldata);\n    function withdraw(uint256[] calldata tokenIds) external returns (uint256[] memory);\n\n    function startAuction(uint256 tokenId, uint256 price) external;\n    function bid(uint256 tokenId, uint256 price) external;\n    function endAuction(uint256 tokenId) external;\n\n    function flashFee(address borrowedToken, uint256 amount) external view returns (uint256);\n\n    function flashLoan(\n        IERC3156FlashBorrowerUpgradeable receiver,\n        address borrowedToken,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n\n    function allValidNFTs(uint256[] calldata tokenIds)\n        external\n        view\n        returns (bool);\n\n    function getAuction(uint256 tokenId) external view returns (uint256, uint256, AuctionState, address);\n    function getDepositor(uint256 tokenId) external view returns (address);\n\n    // /// @notice An event emitted when someone redeems all tokens for the NFT\n    // event TokenRedeemed(address indexed redeemer);\n\n    event AuctionLengthUpdated(uint256 length);\n    /// @notice An event emitted when an auction starts\n    event AuctionStarted(address indexed buyer, uint256 tokenId, uint256 price);\n    /// @notice An event emitted when an auction is won\n    event AuctionWon(address indexed buyer, uint256 tokenId, uint256 price);\n    /// @notice An event emitted when a bid is made\n    event BidMade(address indexed buyer, uint256 tokenId, uint256 price);\n    event CuratorUpdated(address oldCurator, address newCurator);\n    event EligibilityDeployed(uint256 moduleIndex, address eligibilityAddr);\n    event Minted(uint256[] nftIds, uint256[] amounts, address to);\n    event Redeemed(uint256[] nftIds, uint256[] specificIds, address to);\n    event Swapped(\n        uint256[] nftIds,\n        uint256[] amounts,\n        uint256[] specificIds,\n        uint256[] redeemedIds,\n        address to\n    );\n    event VaultInit(\n        uint256 indexed vaultId,\n        address assetAddress,\n        bool is1155,\n        bool allowAllItems\n    );\n    event VaultFeaturesUpdated(\n      bool enableMint,\n      bool enableRandomRedeem,\n      bool enableTargetRedeem,\n      bool enableRandomSwap,\n      bool enableTargetSwap,\n      bool enableBid\n    );\n    event VaultShutdown(address assetAddress, uint256 numItems, address recipient);\n\n    error AuctionEnded();\n    error AuctionLive();\n    error AuctionNotEnded();\n    error AuctionNotLive();\n    error BidDisabled();\n    error BidEnabled();\n    error BidTooLow();\n    error EligibilityAlreadySet();\n    error FeeTooHigh();\n    error IneligibleNFTs();\n    error InvalidAuctionLength();\n    error MintDisabled();\n    error NFTAlreadyInCollection();\n    error NotCurator();\n    error NotNFTOwner();\n    error NotInVault();\n    error NotOwner();\n    error Paused();\n    error RandomRedeemDisabled();\n    error RandomSwapDisabled();\n    error TargetRedeemDisabled();\n    error TargetSwapDisabled();\n    error TooManyNFTs();\n    error InvalidToken();\n    error SameCurator();\n    error ZeroAddress();\n    error ZeroTransferAmount();\n}"
    },
    "src/contracts/interfaces/IFNFTCollectionFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"../proxy/IBeacon.sol\";\nimport \"./IVaultManager.sol\";\n\ninterface IFNFTCollectionFactory is IBeacon {\n  struct VaultFees {\n      bool active;\n      uint64 mintFee;\n      uint64 randomRedeemFee;\n      uint64 targetRedeemFee;\n      uint64 randomSwapFee;\n      uint64 targetSwapFee;\n  }\n\n  // Read functions.\n  function vaultManager() external view returns (IVaultManager);\n\n  function eligibilityManager() external view returns (address);\n\n  function factoryMintFee() external view returns (uint64);\n\n  function factoryRandomRedeemFee() external view returns (uint64);\n\n  function factoryTargetRedeemFee() external view returns (uint64);\n\n  function factoryRandomSwapFee() external view returns (uint64);\n\n  function factoryTargetSwapFee() external view returns (uint64);\n\n  function vaultFees(uint256 vaultId) external view returns (uint256, uint256, uint256, uint256, uint256);\n\n  function flashLoanFee() external view returns (uint256);\n\n  function maxAuctionLength() external view returns (uint256);\n\n  function minAuctionLength() external view returns (uint256);\n\n  function minBidIncrease() external view returns (uint256);\n\n  // Write functions.\n  function __FNFTCollectionFactory_init(address _vaultManager, address _fnftCollection) external;\n\n  function createVault(\n      address _assetAddress,\n      bool is1155,\n      bool allowAllItems,\n      string calldata _name,\n      string calldata _symbol\n  ) external returns (address);\n\n  function setEligibilityManager(address _eligibilityManager) external;\n\n  function setFactoryFees(\n    uint256 _factoryMintFee,\n    uint256 _factoryRandomRedeemFee,\n    uint256 _factoryTargetRedeemFee,\n    uint256 _factoryRandomSwapFee,\n    uint256 _factoryTargetSwapFee,\n    uint256 _flashLoanFee\n  ) external;\n\n  function setFactoryThresholds(\n      uint256 _maxAuctionLength,\n      uint256 _minAuctionLength,\n      uint256 _minBidIncrease\n  ) external;\n\n  function setVaultFees(\n      uint256 vaultId,\n      uint256 _mintFee,\n      uint256 _randomRedeemFee,\n      uint256 _targetRedeemFee,\n      uint256 _randomSwapFee,\n      uint256 _targetSwapFee\n  ) external;\n\n  function disableVaultFees(uint256 vaultId) external;\n\n  event FactoryThresholdsUpdated(uint256 maxAuctionLength, uint256 minAuctionLength, uint256 minBidIncrease);\n  event FeeDistributorUpdated(address oldFeeDistributor, address newFeeDistributor);\n  event FeeExclusionUpdated(address target, bool excluded);\n  event PriceOracleUpdated(address oldPriceOracle, address newPriceOracle);\n  event EligibilityManagerUpdated(address oldEligManager, address newEligManager);\n  event VaultCreated(uint256 indexed vaultId, address curator, address vaultAddress, address assetAddress, string name, string symbol);\n  event VaultFeesUpdated(uint256 vaultId, uint256 mintFee, uint256 randomRedeemFee, uint256 targetRedeemFee, uint256 randomSwapFee, uint256 targetSwapFee);\n  event VaultFeesDisabled(uint256 vaultId);\n  event FactoryFeesUpdated(uint256 mintFee, uint256 randomRedeemFee, uint256 targetRedeemFee, uint256 randomSwapFee, uint256 targetSwapFee, uint256 flashLoanFee);\n\n  error NotVault();\n  error FeeTooHigh();\n  error MaxAuctionLengthOutOfBounds();\n  error MinAuctionLengthOutOfBounds();\n  error MinBidIncreaseOutOfBounds();\n  error ZeroAddress();\n}\n"
    },
    "src/contracts/interfaces/IPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IPausable {\n    function isPaused(uint256 pauseId) external view returns (bool);\n}"
    },
    "src/contracts/interfaces/IVaultManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\ninterface IVaultManager {\n    function fnftSingleFactory() external view returns (address);\n\n    function fnftCollectionFactory() external view returns (address);\n\n    function excludedFromFees(address) external view returns (bool);\n\n    function feeDistributor() external view returns (address);\n\n    function __VaultManager_init(\n        address _weth,\n        address _ifoFactory,\n        address _priceOracle\n    ) external;\n\n    function WETH() external view returns (address);\n\n    function priceOracle() external view returns (address);\n\n    function ifoFactory() external view returns (address);\n\n    function zapContract() external view returns (address);\n\n    function feeReceiver() external view returns (address payable);\n\n    function togglePaused() external;\n\n    function addVault(address _fnft) external returns (uint256 vaultId);\n\n    function setPriceOracle(address _priceOracle) external;\n\n    function setFeeDistributor(address _feeDistributor) external;\n\n    function setFeeExclusion(address _address, bool _excluded) external;\n\n    function setFeeReceiver(address payable _feeReceiver) external;\n\n    function setZapContract(address _zapContract) external;\n\n    function setFNFTCollectionFactory(address _fnftCollectionFactory) external;\n\n    function setFNFTSingleFactory(address _fnftCollectionFactory) external;\n\n    function vault(uint256 vaultId) external view returns (address);\n\n    function vaults(uint256) external view returns (address);\n\n    function numVaults() external view returns (uint);\n\n    event PriceOracleUpdated(address oldPriceOracle, address newPriceOracle);\n    event FeeReceiverUpdated(address oldFeeReceiver, address newFeeReceiver);\n    event ZapContractUpdated(address oldZapContract, address newZapContract);\n    event FNFTCollectionFactoryUpdated(address oldFNFTCollectionFactory, address newFNFTCollectionFactory);\n    event FNFTSingleFactoryUpdated(address oldFNFTSingleFactory, address newFNFTSingleFactory);\n    event VaultAdded(uint256 vaultId, address vault);\n    event FeeDistributorUpdated(address oldFeeDistributor, address newFeeDistributor);\n    event FeeExclusionUpdated(address target, bool excluded);\n\n    error FeeTooHigh();\n    error MaxAuctionLengthOutOfBounds();\n    error MaxReserveFactorTooLow();\n    error MinAuctionLengthOutOfBounds();\n    error MinBidIncreaseOutOfBounds();\n    error MinReserveFactorTooHigh();\n    error MinVotePercentageTooHigh();\n    error MultiplierTooLow();\n    error OnlyFactory();\n    error ZeroAddress();\n}\n"
    },
    "src/contracts/token/ERC20FlashMintUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20FlashMint.sol)\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashBorrowerUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashLenderUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./ERC20Upgradeable.sol\";\n\n/**\n * @dev Implementation of the ERC3156 Flash loans extension, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * Adds the {flashLoan} method, which provides flash loan support at the token\n * level. By default there is no fee, but this can be changed by overriding {flashFee}.\n *\n * _Available since v4.1._\n */\nabstract contract ERC20FlashMintUpgradeable is Initializable, ERC20Upgradeable, IERC3156FlashLenderUpgradeable {\n    function __ERC20FlashMint_init() internal onlyInitializing {\n    }\n\n    function __ERC20FlashMint_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ON_RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    error ExceedsMaxFlashLoan();\n    error FlashLoanNotRepaid();\n    error InvalidFlashLoanReturnValue();\n\n    /**\n     * @dev Returns the maximum amount of tokens available for loan.\n     * @param token The address of the token that is requested.\n     * @return The amont of token that can be loaned.\n     */\n    function maxFlashLoan(address token) public view virtual override returns (uint256) {\n        return token == address(this) ? type(uint256).max - ERC20Upgradeable.totalSupply() : 0;\n    }\n\n    function _flashLoan(\n        IERC3156FlashBorrowerUpgradeable receiver,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) internal returns (bool) {\n        if (amount > maxFlashLoan(token)) revert ExceedsMaxFlashLoan();\n\n        _mint(address(receiver), amount);\n        if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != _ON_RETURN_VALUE) revert InvalidFlashLoanReturnValue();\n        uint256 currentAllowance = allowance(address(receiver), address(this));\n        if (amount + fee > currentAllowance) revert FlashLoanNotRepaid();\n\n        _approve(address(receiver), address(this), currentAllowance - amount - fee);\n\n        _burn(address(receiver), amount);\n        _chargeAndDistributeFees(address(receiver), fee);\n\n        return true;\n    }\n\n    function _chargeAndDistributeFees(address user, uint256 amount) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155ReceiverUpgradeable.sol\";\nimport \"../../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {\n    function __ERC1155Receiver_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Receiver_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "src/contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../libraries/UQ112x112.sol\";\nimport \"../libraries/math/FixedPoint.sol\";\nimport \"./IUniswapV2Factory.sol\";\n\ninterface IPriceOracle {\n    // Struct that contains metadata of two token pair that is stored in the liquidity pool.\n    // Metadata used to calculated TWAP (Time-weighted average price).\n    struct PairInfo {\n        address token0;\n        address token1;\n        uint256 price0CumulativeLast;\n        uint256 price1CumulativeLast;\n        FixedPoint.uq112x112 price0Average;\n        FixedPoint.uq112x112 price1Average;\n        uint216 totalUpdates;\n        uint32 blockTimestampLast;\n        bool exists;\n    }\n\n    function period() external view returns (uint256);\n\n    function minimumPairInfoUpdate() external view returns (uint256);\n\n    function WETH() external view returns (address);\n\n    function factory() external view returns (IUniswapV2Factory);\n\n    function __PriceOracle_init() external;\n\n    function setPeriod(uint256 _period) external;\n\n    function setMinimumPairInfoUpdate(uint256 _minimumPairInfoUpdate) external;\n\n    function getPairAddress(address _token0, address _token1) external view returns (address);\n\n    function getPairInfo(address _token0, address _token1) external view returns (PairInfo memory pairInfo);\n\n    function getPairInfo(address _pair) external view returns (PairInfo memory pairInfo);\n\n    function updatePairInfo(address _token0, address _token1) external;\n\n    function updateFNFTPairInfo(address _fnft) external;\n\n    function createFNFTPair(address _token0) external returns (address);\n\n    function consult(\n        address _token,\n        address _pair,\n        uint256 _amountIn\n    ) external view returns (uint256 amountOut);\n\n    function getFNFTPriceETH(address _fnft, uint256 _amountIn) external view returns (uint256 amountOut);\n\n    event PeriodUpdated(uint256 oldPeriod, uint256 newPeriod);\n    event MinimumPairInfoUpdateUpdated(uint256 oldMinimumPairInfoUpdate, uint256 newMinimumPairInfoUpdate);\n\n    error InvalidToken();\n    error NotEnoughUpdates();\n    error PairInfoAlreadyExists();\n    error PairInfoDoesNotExist();\n}\n"
    },
    "src/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Factory {\n    function INIT_CODE_PAIR_HASH() external view returns (bytes32);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function migrator() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n\n    function setMigrator(address) external;\n\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n}\n"
    },
    "src/contracts/libraries/PriceOracleLibrary.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"../interfaces/IUniswapV2Pair.sol\";\nimport \"./UQ112x112.sol\";\nimport \"./math/FixedPoint.sol\";\nimport \"./math/SafeMath.sol\";\n\nlibrary PriceOracleLibrary {\n    using SafeMath for uint256;\n    using UQ112x112 for uint224;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2**32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(address pair)\n        internal\n        view\n        returns (\n            uint256 price0Cumulative,\n            uint256 price1Cumulative,\n            uint32 blockTimestamp\n        )\n    {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n        \n        //if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp && reserve0 != 0 && reserve1 != 0) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint256(UQ112x112.encode(reserve1).uqdiv(reserve0)) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint256(UQ112x112.encode(reserve0).uqdiv(reserve1)) * timeElapsed;\n        }\n    }\n}\n"
    },
    "src/contracts/libraries/UQ112x112.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n"
    },
    "src/contracts/libraries/math/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport \"./FullMath.sol\";\nimport \"./Babylonian.sol\";\nimport \"./BitMath.sol\";\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 public constant RESOLUTION = 112;\n    uint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n        uint256 z = 0;\n        require(y == 0 || (z = self._x * y) / y == self._x, \"FixedPoint::mul: overflow\");\n        return uq144x112(z);\n    }\n\n    // multiply a UQ112x112 by an int and decode, returning an int\n    // reverts on overflow\n    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\n        uint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);\n        require(z < 2**255, \"FixedPoint::muli: overflow:\");\n        return y < 0 ? -int256(z) : int256(z);\n    }\n\n    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\n    // lossy\n    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n        if (self._x == 0 || other._x == 0) {\n            return uq112x112(0);\n        }\n        uint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\n        uint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\n        uint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\n        uint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\n\n        // partial products\n        uint224 upper = uint224(upper_self) * upper_other; // * 2^0\n        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224\n        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\n        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\n\n        // so the bit shift does not overflow\n        require(upper <= type(uint112).max, \"FixedPoint::muluq: upper overflow\");\n\n        // this cannot exceed 256 bits, all values are 224 bits\n        uint256 sum = uint256(upper << RESOLUTION) + uppers_lowero + uppero_lowers + (lower >> RESOLUTION);\n\n        // so the cast does not overflow\n        require(sum <= type(uint224).max, \"FixedPoint::muluq: sum overflow\");\n\n        return uq112x112(uint224(sum));\n    }\n\n    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112\n    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n        require(other._x > 0, \"FixedPoint::divuq: division by zero\");\n        if (self._x == other._x) {\n            return uq112x112(uint224(Q112));\n        }\n        if (self._x <= type(uint144).max) {\n            uint256 value = (uint256(self._x) << RESOLUTION) / other._x;\n            require(value <= type(uint224).max, \"FixedPoint::divuq: overflow\");\n            return uq112x112(uint224(value));\n        }\n\n        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);\n        require(result <= type(uint224).max, \"FixedPoint::divuq: overflow\");\n        return uq112x112(uint224(result));\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // can be lossy\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint::fraction: division by zero\");\n        if (numerator == 0) return FixedPoint.uq112x112(0);\n\n        if (numerator <= type(uint144).max) {\n            uint256 result = (numerator << RESOLUTION) / denominator;\n            require(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n            return uq112x112(uint224(result));\n        } else {\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n            require(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n            return uq112x112(uint224(result));\n        }\n    }\n\n    // take the reciprocal of a UQ112x112\n    // reverts on overflow\n    // lossy\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        require(self._x != 0, \"FixedPoint::reciprocal: reciprocal of zero\");\n        require(self._x != 1, \"FixedPoint::reciprocal: overflow\");\n        return uq112x112(uint224(Q224 / self._x));\n    }\n\n    // square root of a UQ112x112\n    // lossy between 0/1 and 40 bits\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        if (self._x <= type(uint144).max) {\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\n        }\n\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\n        safeShiftBits -= safeShiftBits % 2;\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\n    }\n}\n"
    },
    "src/contracts/libraries/math/FullMath.sol": {
      "content": "// SPDX-License-Identifier: CC-BY-4.0\npragma solidity 0.8.13;\n\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\n// license is CC-BY-4.0\nlibrary FullMath {\n    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {\n        uint256 mm = mulmod(x, y, type(uint256).max);\n        l = x * y;\n        h = mm - l;\n        if (mm < l) h -= 1;\n    }\n\n    function fullDiv(\n        uint256 l,\n        uint256 h,\n        uint256 d\n    ) private pure returns (uint256) {\n        uint256 pow2 = d & (type(uint8).max - d + 1);\n        d /= pow2;\n        l /= pow2;\n        l += h * (((type(uint8).max - pow2 + 1)) / pow2 + 1);\n        uint256 r = 1;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        return l * r;\n    }\n\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) internal pure returns (uint256) {\n        (uint256 l, uint256 h) = fullMul(x, y);\n\n        uint256 mm = mulmod(x, y, d);\n        if (mm > l) h -= 1;\n        l -= mm;\n\n        if (h == 0) return l / d;\n\n        require(h < d, \"FullMath: FULLDIV_OVERFLOW\");\n        return fullDiv(l, h, d);\n    }\n}\n"
    },
    "src/contracts/libraries/math/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n"
    },
    "src/contracts/libraries/math/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nlibrary BitMath {\n    // returns the 0 indexed position of the most significant bit of the input x\n    // s.t. x >= 2**msb and x < 2**(msb+1)\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0, \"BitMath::mostSignificantBit: zero\");\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n\n    // returns the 0 indexed position of the least significant bit of the input x\n    // s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\n    // i.e. the bit at the index is set and the mask of all lower bits is 0\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0, \"BitMath::leastSignificantBit: zero\");\n\n        r = 255;\n        if (x & type(uint256).max > 0) {\n            r -= 128;\n        } else {\n            x >>= 128;\n        }\n        if (x & type(uint256).max > 0) {\n            r -= 64;\n        } else {\n            x >>= 64;\n        }\n        if (x & type(uint256).max > 0) {\n            r -= 32;\n        } else {\n            x >>= 32;\n        }\n        if (x & type(uint256).max > 0) {\n            r -= 16;\n        } else {\n            x >>= 16;\n        }\n        if (x & type(uint256).max > 0) {\n            r -= 8;\n        } else {\n            x >>= 8;\n        }\n        if (x & 0xf > 0) {\n            r -= 4;\n        } else {\n            x >>= 4;\n        }\n        if (x & 0x3 > 0) {\n            r -= 2;\n        } else {\n            x >>= 2;\n        }\n        if (x & 0x1 > 0) r -= 1;\n    }\n}\n"
    },
    "src/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Pair {\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n}\n"
    },
    "src/contracts/libraries/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n}"
    },
    "src/contracts/interfaces/ILPStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./IVaultManager.sol\";\nimport \"./IStakingTokenProvider.sol\";\nimport \"../token/LPStakingXTokenUpgradeable.sol\";\n\ninterface ILPStaking {\n    struct StakingPool {\n        address stakingToken;\n        address baseToken;\n    }\n\n    function vaultManager() external view returns (IVaultManager);\n\n    function stakingTokenProvider() external view returns (IStakingTokenProvider);\n\n    function lpStakingXToken() external view returns (LPStakingXTokenUpgradeable);\n\n    function vaultStakingInfo(uint256) external view returns (address, address);\n\n    function __LPStaking__init(address _vaultManager, address _stakingTokenProvider) external;\n\n    function setStakingTokenProvider(address _stakingTokenProvider) external;\n\n    function addPoolForVault(uint256 vaultId) external;\n\n    function updatePoolForVaults(uint256[] calldata vaultIds) external;\n\n    function updatePoolForVault(uint256 vaultId) external;\n\n    function receiveRewards(uint256 vaultId, uint256 amount) external returns (bool);\n\n    function deposit(uint256 vaultId, uint256 amount) external;\n\n    function timelockDepositFor(uint256 vaultId, address account, uint256 amount, uint256 timelockLength) external;\n\n    function exit(uint256 vaultId) external;\n\n    function emergencyExitAndClaim(address _stakingToken, address _baseToken) external;\n\n    function emergencyExit(address _stakingToken, address _baseToken) external;\n\n    function withdrawTo(uint256 vaultId, uint256 amount, address to) external;\n\n    function claimRewardsTo(uint256 vaultId, address to) external;\n\n    function claimMultipleRewards(uint256[] calldata vaultIds) external;\n\n    function xToken(uint256 vaultId) external view returns (LPStakingXTokenUpgradeable);\n\n    function xTokenAddr(address stakedToken, address baseToken) external view returns (address);\n\n    function balanceOf(uint256 vaultId, address addr) external view returns (uint256);\n\n    function lockedUntil(uint256 vaultId, address who) external view returns (uint256);\n\n    function lockedLPBalance(uint256 vaultId, address who) external view returns (uint256);\n\n    function xToken(StakingPool memory pool) external view returns (LPStakingXTokenUpgradeable);\n\n    function retrieveTokens(uint256 vaultId, uint256 amount, address from, address to) external;\n\n    event StakingPoolCreated(uint256 vaultId, address xToken, address baseToken);\n    event StakingPoolUpdated(uint256 vaultId, address xToken);\n    event FeesReceived(uint256 vaultId, uint256 amount, address xToken);\n    event LPDeposited(uint256 vaultId, uint256 amount, address xToken, address sender);\n    event XTokenWithdrawn(uint256 vaultId, uint256 amount, address xToken, address sender);\n    event StakingTokenProviderUpdated(address oldStakingTokenProvider, address newStakingTokenProvider);\n\n    error NotAPool();\n    error NotDeployingProperDistro();\n    error NotExcludedFromFees();\n    error NothingToMigrate();\n    error PoolAlreadyExists();\n    error PoolDoesNotExist();\n    error LPStakingXTokenAlreadySet();\n    error TimelockTooLong();\n    error VaultManagerAlreadySet();\n    error VaultManagerNotSet();\n    error ZeroAddress();\n}\n"
    },
    "src/contracts/interfaces/IFNFTStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./IVaultManager.sol\";\nimport \"./ITimelockExcludeList.sol\";\n\n\ninterface IFNFTStaking {\n    function vaultManager() external view returns (IVaultManager);\n\n    function inventoryLockTimeErc20() external view returns (uint256);\n\n    function timelockExcludeList() external view returns (ITimelockExcludeList);\n\n    function __FNFTStaking_init(address _vaultManager) external;\n\n    function setTimelockExcludeList(address _timelockExcludeList) external;\n\n    function setInventoryLockTimeErc20(uint256 _inventoryLockTimeErc20) external;\n\n    function isAddressTimelockExcluded(address addr, uint256 vaultId) external returns (bool);\n\n    function deployXTokenForVault(uint256 vaultId) external;\n\n    function receiveRewards(uint256 vaultId, uint256 amount) external returns (bool);\n\n    function deposit(uint256 vaultId, uint256 _amount) external;\n\n    function timelockMintFor(uint256 vaultId, uint256 amount, address to, uint256 timelockLength) external returns (uint256);\n\n    function withdraw(uint256 vaultId, uint256 _share) external;\n\n    function xTokenShareValue(uint256 vaultId) external returns (uint256);\n\n    function timelockUntil(uint256 vaultId, address who) external returns (uint256);\n\n    function balanceOf(uint256 vaultId, address who) external returns (uint256);\n\n    function xTokenAddr(address baseToken) external returns (address);\n\n    function vaultXToken(uint256 vaultId) external view returns (address);\n\n    event StakingPoolCreated(uint256 vaultId, address xToken, address baseToken);\n    event FeesReceived(uint256 vaultId, uint256 amount, address xToken);\n    event BaseTokenDeposited(uint256 vaultId, uint256 baseTokenAmount, uint256 amount, uint256 timelockUntil, address sender);\n    event XTokenWithdrawn(uint256 vaultId, uint256 baseTokenAmount, uint256 amount, address sender);\n\n    event InventoryLockTimeErc20Updated(uint256 oldInventoryLockTimeErc20, uint256 newInventoryLockTimeErc20);\n    event TimelockExcludeListUpdated(address oldTimelockExcludeList, address newTimelockExcludeList);\n\n    error LockTooLong();\n    error NotExcludedFromFees();\n    error NotZapContract();\n    error XTokenNotDeployed();\n\n}"
    },
    "src/contracts/interfaces/IStakingTokenProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IStakingTokenProvider {\n    function uniLikeExchange() external returns (address);\n\n    function defaultPairedToken() external returns (address);\n\n    function defaultPrefix() external returns (string memory);\n\n    function pairedToken(address) external returns (address);\n\n    function pairedPrefix(address) external returns (string memory);\n\n    function __StakingTokenProvider_init(address _uniLikeExchange, address _defaultPairedtoken, string memory _defaultPrefix) external;\n\n    function setPairedTokenForVaultToken(address _vaultToken, address _newPairedToken, string calldata _newPrefix) external;\n\n    function setDefaultPairedToken(address _defaultPairedToken, string calldata _defaultPrefix) external;\n\n    function stakingTokenForVaultToken(address _vaultToken) external view returns (address);\n\n    function nameForStakingToken(address _vaultToken) external view returns (string memory);\n\n    function pairForVaultToken(address _vaultToken, address _pairedToken) external view returns (address);\n\n    event DefaultPairedTokenUpdated(address oldDefaultPairedToken, address newDefaultPairedToken);\n    event PairedTokenForVaultUpdated(address vaultToken, address oldPairedtoken, address newPairedToken);\n\n    error IdenticalAddress();\n    error ZeroAddress();\n}"
    },
    "src/contracts/token/LPStakingXTokenUpgradeable.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/// @title Reward-Paying Token (renamed from Dividend)\n/// @author Roger Wu (https://github.com/roger-wu)\n/// @dev A mintable ERC20 token that allows anyone to pay and distribute a target token\n///  to token holders as dividends and allows token holders to withdraw their dividends.\n///  Reference: the source code of PoWH3D: https://etherscan.io/address/0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe#code\ncontract LPStakingXTokenUpgradeable is OwnableUpgradeable, ERC20Upgradeable {\n  using SafeCast for uint256;\n  using SafeCast for int256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  IERC20Upgradeable public target;\n\n  // With `magnitude`, we can properly distribute dividends even if the amount of received target is small.\n  // For more discussion about choosing the value of `magnitude`,\n  //  see https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\n  uint256 constant internal magnitude = 2**128;\n\n  uint256 internal magnifiedRewardPerShare;\n\n  // About dividendCorrection:\n  // If the token balance of a `_user` is never changed, the dividend of `_user` can be computed with:\n  //   `dividendOf(_user) = dividendPerShare * balanceOf(_user)`.\n  // When `balanceOf(_user)` is changed (via minting/burning/transferring tokens),\n  //   `dividendOf(_user)` should not be changed,\n  //   but the computed value of `dividendPerShare * balanceOf(_user)` is changed.\n  // To keep the `dividendOf(_user)` unchanged, we add a correction term:\n  //   `dividendOf(_user) = dividendPerShare * balanceOf(_user) + dividendCorrectionOf(_user)`,\n  //   where `dividendCorrectionOf(_user)` is updated whenever `balanceOf(_user)` is changed:\n  //   `dividendCorrectionOf(_user) = dividendPerShare * (old balanceOf(_user)) - (new balanceOf(_user))`.\n  // So now `dividendOf(_user)` returns the same value before and after `balanceOf(_user)` is changed.\n  mapping(address => int256) internal magnifiedRewardCorrections;\n  mapping(address => uint256) internal withdrawnRewards;\n\n  mapping(address => uint256) internal timelock;\n\n  event Timelocked(address user, uint256 amount, uint256 until);\n\n  error UserIsLocked();\n  error ZeroAmount();\n  error ZeroSupply();\n\n  function __LPStakingXToken_init(IERC20Upgradeable _target, string memory _name, string memory _symbol) public initializer {\n    __Ownable_init();\n    __ERC20_init(_name, _symbol);\n    target = _target;\n  }\n\n  function transfer(address recipient, uint256 amount)\n      public\n      virtual\n      override\n      returns (bool)\n  {\n      _transfer(_msgSender(), recipient, amount);\n      return true;\n  }\n\n  /**\n    * @dev See {IERC20-transferFrom}.\n    *\n    * Emits an {Approval} event indicating the updated allowance. This is not\n    * required by the EIP. See the note at the beginning of {ERC20}.\n    *\n    * Requirements:\n    *\n    * - `sender` and `recipient` cannot be the zero address.\n    * - `sender` must have a balance of at least `amount`.\n    * - the caller must have allowance for ``sender``'s tokens of at least\n    * `amount`.\n    */\n  function transferFrom(address sender, address recipient, uint256 amount)\n      public\n      virtual\n      override\n      returns (bool)\n  {\n      _transfer(sender, recipient, amount);\n      _approve(sender, _msgSender(), allowance(sender, _msgSender()) - amount);\n      return true;\n  }\n\n  function mint(address account, uint256 amount) public onlyOwner virtual {\n      _mint(account, amount);\n  }\n\n  function timelockMint(address account, uint256 amount, uint256 timelockLength) public onlyOwner virtual {\n    uint256 timelockFinish = block.timestamp + timelockLength;\n    timelock[account] = timelockFinish;\n    emit Timelocked(account, amount, timelockFinish);\n    _mint(account, amount);\n  }\n\n  function timelockUntil(address account) public view returns (uint256) {\n    return timelock[account];\n  }\n\n  /**\n    * @dev Destroys `amount` tokens from `account`, without deducting from the caller's\n    * allowance. Dangerous.\n    *\n    * See {ERC20-_burn} and {ERC20-allowance}.\n    */\n  function burnFrom(address account, uint256 amount) public virtual onlyOwner {\n      _burn(account, amount);\n  }\n\n  /// @notice Distributes target to token holders as dividends.\n  /// @dev It reverts if the total supply of tokens is 0.\n  /// It emits the `RewardsDistributed` event if the amount of received target is greater than 0.\n  /// About undistributed target tokens:\n  ///   In each distribution, there is a small amount of target not distributed,\n  ///     the magnified amount of which is\n  ///     `(amount * magnitude) % totalSupply()`.\n  ///   With a well-chosen `magnitude`, the amount of undistributed target\n  ///     (de-magnified) in a distribution can be less than 1 wei.\n  ///   We can actually keep track of the undistributed target in a distribution\n  ///     and try to distribute it in the next distribution,\n  ///     but keeping track of such data on-chain costs much more than\n  ///     the saved target, so we don't do that.\n  function distributeRewards(uint amount) external virtual onlyOwner {\n    if (totalSupply() == 0) revert ZeroSupply();\n    if (amount == 0) revert ZeroAmount();\n\n    // Because we receive the tokens from the staking contract, we assume the tokens have been received.\n    magnifiedRewardPerShare = magnifiedRewardPerShare + (amount * magnitude / totalSupply());\n\n    emit RewardsDistributed(msg.sender, amount);\n  }\n\n  /// @notice Withdraws the target distributed to the sender.\n  /// @dev It emits a `RewardWithdrawn` event if the amount of withdrawn target is greater than 0.\n  function withdrawReward(address user) external onlyOwner {\n    uint256 _withdrawableReward = withdrawableRewardOf(user);\n    if (_withdrawableReward > 0) {\n      withdrawnRewards[user] = withdrawnRewards[user] + _withdrawableReward;\n      target.safeTransfer(user, _withdrawableReward);\n      emit RewardWithdrawn(user, _withdrawableReward);\n    }\n  }\n\n  /// @notice View the amount of dividend in wei that an address can withdraw.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\n  function dividendOf(address _owner) public view returns(uint256) {\n    return withdrawableRewardOf(_owner);\n  }\n\n  /// @notice View the amount of dividend in wei that an address can withdraw.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\n  function withdrawableRewardOf(address _owner) internal view returns(uint256) {\n    return accumulativeRewardOf(_owner) - withdrawnRewards[_owner];\n  }\n\n  /// @notice View the amount of dividend in wei that an address has withdrawn.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` has withdrawn.\n  function withdrawnRewardOf(address _owner) public view returns(uint256) {\n    return withdrawnRewards[_owner];\n  }\n\n\n  /// @notice View the amount of dividend in wei that an address has earned in total.\n  /// @dev accumulativeRewardOf(_owner) = withdrawableRewardOf(_owner) + withdrawnRewardOf(_owner)\n  /// = (magnifiedRewardPerShare * balanceOf(_owner) + magnifiedRewardCorrections[_owner]) / magnitude\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` has earned in total.\n  function accumulativeRewardOf(address _owner) public view returns(uint256) {\n    return ((magnifiedRewardPerShare * balanceOf(_owner)).toInt256() + magnifiedRewardCorrections[_owner]).toUint256() / magnitude;\n  }\n\n  /// @dev Internal function that transfer tokens from one address to another.\n  /// Update magnifiedRewardCorrections to keep dividends unchanged.\n  /// @param from The address to transfer from.\n  /// @param to The address to transfer to.\n  /// @param value The amount to be transferred.\n  function _transfer(address from, address to, uint256 value) internal override {\n    if (timelock[from] >= block.timestamp) revert UserIsLocked();\n    super._transfer(from, to, value);\n\n    int256 _magCorrection = (magnifiedRewardPerShare * value).toInt256();\n    magnifiedRewardCorrections[from] = magnifiedRewardCorrections[from] + _magCorrection;\n    magnifiedRewardCorrections[to] = magnifiedRewardCorrections[to] - _magCorrection;\n  }\n\n  /// @dev Internal function that mints tokens to an account.\n  /// Update magnifiedRewardCorrections to keep dividends unchanged.\n  /// @param account The account that will receive the created tokens.\n  /// @param value The amount that will be created.\n  function _mint(address account, uint256 value) internal override {\n    super._mint(account, value);\n\n    magnifiedRewardCorrections[account] = magnifiedRewardCorrections[account] - (magnifiedRewardPerShare * value).toInt256();\n  }\n\n  /// @dev Internal function that burns an amount of the token of a given account.\n  /// Update magnifiedRewardCorrections to keep dividends unchanged.\n  /// @param account The account whose tokens will be burnt.\n  /// @param value The amount that will be burnt.\n  function _burn(address account, uint256 value) internal override {\n    if (timelock[account] >= block.timestamp) revert UserIsLocked();\n    super._burn(account, value);\n\n    magnifiedRewardCorrections[account] = magnifiedRewardCorrections[account] + (magnifiedRewardPerShare * value).toInt256();\n  }\n\n\n  /// @dev This event MUST emit when target is distributed to token holders.\n  /// @param from The address which sends target to this contract.\n  /// @param weiAmount The amount of distributed target in wei.\n  event RewardsDistributed(\n    address indexed from,\n    uint256 weiAmount\n  );\n\n  /// @dev This event MUST emit when an address withdraws their dividend.\n  /// @param to The address which withdraws target from this contract.\n  /// @param weiAmount The amount of withdrawn target in wei.\n  event RewardWithdrawn(\n    address indexed to,\n    uint256 weiAmount\n  );\n}"
    },
    "src/contracts/token/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    function _setMetadata(string memory name_, string memory symbol_) internal {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20Upgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/contracts/interfaces/ITimelockExcludeList.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface ITimelockExcludeList {\n    function isExcluded(address addr, uint256 vaultId) external view returns (bool);\n}"
    },
    "src/contracts/proxy/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function childImplementation() external view returns (address);\n    function upgradeChildTo(address newImplementation) external;\n}"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashLenderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashLender.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC3156FlashBorrowerUpgradeable.sol\";\n\n/**\n * @dev Interface of the ERC3156 FlashLender, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashLenderUpgradeable {\n    /**\n     * @dev The amount of currency available to be lended.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrowerUpgradeable receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "src/contracts/FNFTSingle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashBorrowerUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IPriceOracle} from \"./PriceOracle.sol\";\nimport \"./interfaces/IIFO.sol\";\nimport \"./interfaces/IIFOFactory.sol\";\nimport \"./interfaces/IFeeDistributor.sol\";\nimport \"./interfaces/IFNFTSingle.sol\";\nimport \"./interfaces/IFNFTSingleFactory.sol\";\nimport \"./interfaces/IPausable.sol\";\nimport \"./interfaces/IUniswapV2Pair.sol\";\nimport \"./interfaces/IVaultManager.sol\";\nimport \"./interfaces/IWETH.sol\";\nimport \"./token/ERC20FlashMintUpgradeable.sol\";\n\ncontract FNFTSingle is\n    IFNFTSingle,\n    OwnableUpgradeable,\n    IERC165,\n    ERC20FlashMintUpgradeable,\n    ERC721HolderUpgradeable\n{\n    using Address for address;\n\n    /// @notice a mapping of users to their desired token price\n    mapping(address => uint256) public override userReservePrice;\n\n    State public override auctionState;\n\n    IUniswapV2Pair public override pair;\n\n    /// @notice the governance contract for all FNFTSingles\n    IVaultManager public override vaultManager;\n\n    /// @notice the governance contract which gets paid in ETH\n    IFNFTSingleFactory public override factory;\n\n    /// @notice the address who initially deposited the NFT\n    address public override curator;\n\n    /// @notice the ERC721 token address of the vault's token\n    address public override token;\n\n    /// @notice the current user winning the token auction\n    address payable public override winning;\n\n    /// @notice whether or not this FNFTSingle has been verified by DAO\n    bool public override verified;\n\n    /// @notice the unix timestamp end time of the token auction\n    uint256 public override auctionEnd;\n\n    /// @notice the length of auctions\n    uint256 public override auctionLength;\n\n    /// @notice the AUM fee paid to the curator yearly. 3 decimals. ie. 100 = 10%\n    uint256 public override curatorFee;\n\n    /// @notice the ERC721 token id of the nft's token\n    uint256 public override tokenId;\n\n    /// @notice initial price of NFT set by curator on creation\n    uint256 public override initialReserve;\n\n    /// @notice the last timestamp where fees were claimed\n    uint256 public override lastClaimed;\n\n    /// @notice the current price of the token during an auction\n    uint256 public override livePrice;\n\n    /// @notice reservePrice * votingTokens\n    uint256 public override reserveTotal;\n\n    uint256 public override vaultId;\n\n    /// @notice the number of ownership tokens voting on the reserve price at any given time\n    uint256 public override votingTokens;\n\n    function __FNFTSingle_init(\n        string memory _name,\n        string memory _symbol,\n        address _curator,\n        address _token,\n        uint256 _tokenId,\n        uint256 _supply,\n        uint256 _listPrice,\n        uint256 _curatorFee\n    ) external override initializer {\n        if (_curator == address(0)) revert ZeroAddress();\n        if (_token == address(0)) revert ZeroAddress();\n\n        __Ownable_init();\n        __ERC20_init(_name, _symbol);\n        __ERC721Holder_init();\n\n        IFNFTSingleFactory _factory = IFNFTSingleFactory(msg.sender);\n        IVaultManager _vaultManager = IVaultManager(_factory.vaultManager());\n\n        if (_curatorFee > _factory.maxCuratorFee()) revert FeeTooHigh();\n\n        // set storage variables\n        factory = _factory;\n        vaultManager = _vaultManager;\n        token = _token;\n        vaultId = _vaultManager.numVaults();\n        tokenId = _tokenId;\n        auctionLength = 3 days;\n        curator = _curator;\n        curatorFee = _curatorFee;\n        lastClaimed = block.timestamp;\n        userReservePrice[_curator] = _listPrice;\n        initialReserve = _listPrice;\n        pair = IUniswapV2Pair(IPriceOracle(_vaultManager.priceOracle()).createFNFTPair(address(this)));\n        _mint(_curator, _supply);\n    }\n\n    /// @notice an external function to bid on purchasing the vaults NFT. The msg.value is the bid amount\n    function bid() external payable override {\n        _onlyOwnerIfPaused(4);\n        if (auctionState != State.Live) revert AuctionNotLive();\n        uint256 increase = factory.minBidIncrease() + 10000;\n        if (msg.value * 10000 < livePrice * increase) revert BidTooLow();\n        if (block.timestamp >= auctionEnd) revert AuctionEnded();\n\n        // If bid is within 15 minutes of auction end, extend auction\n        if (auctionEnd - block.timestamp <= 15 minutes) {\n            auctionEnd += 15 minutes;\n        }\n\n        _sendETHOrWETH(winning, livePrice);\n\n        livePrice = msg.value;\n        winning = payable(msg.sender);\n\n        emit BidMade(msg.sender, msg.value);\n    }\n\n    /// @notice an external function to burn ERC20 tokens to receive ETH from ERC721 token purchase\n    function cash() external override {\n        _onlyOwnerIfPaused(4);\n        if (auctionState != State.Ended) revert AuctionNotEnded();\n        uint256 bal = balanceOf(msg.sender);\n        if (bal == 0) revert NoTokens();\n\n        uint256 share = (bal * address(this).balance) / totalSupply();\n        _burn(msg.sender, bal);\n\n        _sendETHOrWETH(payable(msg.sender), share);\n\n        emit CashWithdrawn(msg.sender, share);\n    }\n\n    /// @notice external function to claim fees for the curator and governance\n    function claimCuratorFees() external override {\n        _onlyOwnerIfPaused(6);\n        _claimCuratorFees();\n    }\n\n    function buyItNow() external payable override {\n        _onlyOwnerIfPaused(3);\n        if (auctionState != State.Inactive) revert AuctionLive();\n        uint256 price = buyItNowPrice();\n        if (price == 0) revert PriceTooLow();\n        if (msg.value < price) revert NotEnoughETH();\n\n        _claimCuratorFees();\n\n        // deposit weth\n        IWETH(vaultManager.WETH()).deposit{value: msg.value}();\n\n        // transfer erc721 to buyer\n        IERC721(token).transferFrom(address(this), msg.sender, tokenId);\n\n        auctionState = State.Ended;\n\n        emit AuctionWon(msg.sender, price);\n    }\n\n    /// @notice an external function to end an auction after the timer has run out\n    function end() external override {\n        _onlyOwnerIfPaused(4);\n        if (auctionState != State.Live) revert AuctionNotLive();\n        if (block.timestamp < auctionEnd) revert AuctionNotEnded();\n\n        _claimCuratorFees();\n\n        // transfer erc721 to winner\n        IERC721(token).transferFrom(address(this), winning, tokenId);\n\n        auctionState = State.Ended;\n\n        emit AuctionWon(winning, livePrice);\n    }\n\n    function getAuctionPrice() external view override returns (uint256) {\n        return _getAuctionPrice();\n    }\n\n    function getQuorum() external view override returns (uint256) {\n        return _getQuorum();\n    }\n\n    /// @notice allow governance to boot a bad actor curator\n    /// @param _curator the new curator\n    function kickCurator(address _curator) external override onlyOwner {\n        if (curator == _curator) revert SameCurator();\n        emit CuratorKicked(curator, _curator);\n        curator = _curator;\n    }\n\n    /// @notice an external function to burn all ERC20 tokens to receive the ERC721 token\n    function redeem() external override {\n        _onlyOwnerIfPaused(2);\n        if (auctionState != State.Inactive) revert AuctionLive();\n        _burn(msg.sender, totalSupply());\n\n        // transfer erc721 to redeemer\n        IERC721(token).transferFrom(address(this), msg.sender, tokenId);\n\n        auctionState = State.Redeemed;\n\n        emit TokenRedeemed(msg.sender);\n    }\n\n    /// @notice allow governance to remove bad reserve prices\n    function removeReserve(address _user) external override onlyOwner {\n        if (auctionState != State.Inactive) revert AuctionLive();\n\n        uint256 old = userReservePrice[_user];\n        if (old == 0) revert NotAnUpdate();\n\n        uint256 weight = balanceOf(_user);\n\n        votingTokens -= weight;\n        reserveTotal -= weight * old;\n\n        userReservePrice[_user] = 0;\n\n        emit PriceUpdated(_user, 0);\n    }\n\n    function setVaultMetadata(\n        string calldata name_,\n        string calldata symbol_\n    ) external override {\n        _onlyPrivileged();\n        _setMetadata(name_, symbol_);\n    }\n\n    /// @notice kick off an auction. Must send reservePrice in ETH\n    function start() external payable override {\n        _onlyOwnerIfPaused(4);\n        if (auctionState != State.Inactive) revert AuctionLive();\n        uint256 _auctionPrice = _getAuctionPrice();\n        if (_auctionPrice == 0 || msg.value < _auctionPrice) revert BidTooLow();\n\n        auctionEnd = block.timestamp + auctionLength;\n        auctionState = State.Live;\n\n        livePrice = msg.value;\n        winning = payable(msg.sender);\n\n        emit AuctionStarted(msg.sender, msg.value);\n    }\n\n    function toggleVerified() external override onlyOwner {\n        bool _verified = !verified;\n        verified = _verified;\n        emit Verified(_verified);\n    }\n\n    /// @notice allow curator to update the auction length\n    /// @param _length the new base price\n    function setAuctionLength(uint256 _length) external override {\n        _onlyPrivileged();\n        if (\n            _length < factory.minAuctionLength() || _length > factory.maxAuctionLength()\n        ) revert InvalidAuctionLength();\n\n        auctionLength = _length;\n        emit AuctionLengthUpdated(_length);\n    }\n\n    /// @notice allow curator to update the curator address\n    /// @param _curator the new curator\n    function setCurator(address _curator) external override {\n        _onlyPrivileged();\n        if (curator == _curator) revert SameCurator();\n        emit CuratorUpdated(curator, _curator);\n        curator = _curator;\n    }\n\n    /// @notice allow the curator to change their fee\n    /// @param _curatorFee the new fee\n    function setFee(uint256 _curatorFee) external override {\n        _onlyPrivileged();\n        if (_curatorFee >= curatorFee) revert CanNotRaise();\n        if (_curatorFee > factory.maxCuratorFee()) revert FeeTooHigh();\n\n        _claimCuratorFees();\n\n        curatorFee = _curatorFee;\n        emit CuratorFeeUpdated(_curatorFee);\n    }\n\n    /// @notice a function for an end user to update their desired sale price\n    /// @param newUserReserve the desired price in ETH\n    function updateUserPrice(uint256 newUserReserve) external override {\n        _onlyOwnerIfPaused(7);\n        if (auctionState != State.Inactive) revert AuctionLive();\n        uint256 previousUserReserve = userReservePrice[msg.sender];\n        if (newUserReserve == previousUserReserve) revert NotAnUpdate();\n\n        uint256 weight = balanceOf(msg.sender);\n\n        if (votingTokens == 0) {\n            _validateUserPrice(initialReserve, newUserReserve);\n\n            votingTokens = weight;\n            reserveTotal = weight * newUserReserve;\n        }\n        // they are the only one voting\n        else if (weight == votingTokens && previousUserReserve != 0) {\n            _validateUserPrice(previousUserReserve, newUserReserve);\n\n            reserveTotal = weight * newUserReserve;\n        }\n        // previously they were not voting\n        else if (previousUserReserve == 0) {\n            uint256 averageReserve = reserveTotal / votingTokens;\n\n            _validateUserPrice(averageReserve, newUserReserve);\n\n            votingTokens += weight;\n            reserveTotal += weight * newUserReserve;\n        }\n        // they no longer want to vote\n        else if (newUserReserve == 0) {\n            votingTokens -= weight;\n            reserveTotal -= weight * previousUserReserve;\n        }\n        // they are updating their vote\n        else {\n            uint256 averageReserve = (reserveTotal - (previousUserReserve * weight)) / (votingTokens - weight);\n\n            _validateUserPrice(averageReserve, newUserReserve);\n\n            reserveTotal = reserveTotal + (weight * newUserReserve) - (weight * previousUserReserve);\n        }\n\n        userReservePrice[msg.sender] = newUserReserve;\n\n        emit PriceUpdated(msg.sender, newUserReserve);\n    }\n\n    function buyItNowPrice() public view override returns (uint256) {\n        return (_getAuctionPrice() * factory.instantBuyMultiplier()) / 10;\n    }\n\n    function flashFee(address borrowedToken, uint256 amount) public view override (\n        IERC3156FlashLenderUpgradeable,\n        IFNFTSingle\n    ) returns (uint256) {\n        if (borrowedToken != address(this)) revert InvalidToken();\n        return factory.flashLoanFee() * amount / 10000;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrowerUpgradeable receiver,\n        address borrowedToken,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override (\n        IERC3156FlashLenderUpgradeable,\n        IFNFTSingle\n    ) returns (bool) {\n        _onlyOwnerIfPaused(5);\n        uint256 flashLoanFee = vaultManager.excludedFromFees(address(receiver)) ? 0 : flashFee(borrowedToken, amount);\n        return _flashLoan(receiver, borrowedToken, amount, flashLoanFee, data);\n    }\n\n    function reservePrice() public view override returns (uint256) {\n        return votingTokens == 0 ? 0 : reserveTotal / votingTokens;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public pure override(IERC165) returns (bool) {\n        return interfaceId == type(IFNFTSingle).interfaceId ||\n                interfaceId == type(IERC165).interfaceId;\n    }\n\n    // Sending ETH is not guaranteed complete, and the method used here will return false if\n    // it fails. For example, a contract can block ETH transfer, or might use\n    // an excessive amount of gas, thereby griefing a new bidder.\n    // We should limit the gas used in transfers, and handle failure cases.\n    function _attemptETHTransfer(address to, uint256 value) internal returns (bool) {\n        // Here increase the gas limit a reasonable amount above the default, and try\n        // to send ETH to the recipient.\n        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\n        (bool success, ) = to.call{value: value, gas: 30000}(\"\");\n        return success;\n    }\n\n    function _afterTokenTransfer(\n        address,\n        address,\n        uint256\n    ) internal virtual override {\n        address priceOracle = vaultManager.priceOracle();\n        if (priceOracle != address(0)) {\n            IPriceOracle(priceOracle).updateFNFTPairInfo(address(this));\n        }\n    }\n\n    /// @notice an internal function used to update sender and receivers price on token transfer\n    /// @param _from the ERC20 token sender\n    /// @param _to the ERC20 token receiver\n    /// @param _amount the ERC20 token amount\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal virtual override {\n        if (auctionState == State.Inactive) {\n            uint256 sendersReservePrice = userReservePrice[_from];\n            uint256 receiversReservePrice = userReservePrice[_to];\n            // only do something if users have different reserve price\n            if (receiversReservePrice != sendersReservePrice) {\n                // Receiver has not voted on a reserve price\n                // NOTE: the sender address could have voted or not\n                if (receiversReservePrice == 0) {\n                    // subtract the total amount of tokens voting on what the reserve price should be\n                    // NOTE: there would never be a situation where the sender has not voted, because all the tokens are minted to the curator on init,\n                    //     _and_ the curator's votes are initially set at the list price\n                    votingTokens -= _amount;\n                    // subtract the avg reserve price by the amount of tokens the\n                    reserveTotal -= _amount * sendersReservePrice;\n                }\n                // the new holder is a voter (implied from the `else`) _and_ old holder is not a voter\n                else if (sendersReservePrice == 0) {\n                    // since the new holder is a voter: add the tokens being sent to the amount of tokens currently voting\n                    votingTokens += _amount;\n                    // _and_ since they are a voter:\n                    // multiply the amount of tokens they're receiving by their previously set reserve price, since they have specified their reservePrice already\n                    reserveTotal += _amount * receiversReservePrice;\n                }\n                // both holders are voters\n                else {\n                    // set the new reserve price to the previous reserve price, plus the difference between the receivers reserve and the senders reserve (NOTE: could be negative)\n                    // - edge cases:\n                    //      - the sender and receiver are the only voters and they have the same vote \n                    //      - the sender and receiver are the only voters but the receivers reserve is higher than the senders reserve \n                    reserveTotal = reserveTotal + (_amount * receiversReservePrice) - (_amount * sendersReservePrice);\n                }\n            }\n        }\n    }\n\n    /// @dev interal fuction to calculate and mint fees\n    function _claimCuratorFees() internal {\n        if (auctionState == State.Ended) revert AuctionEnded();\n\n        // get how much in fees the curator would make in a year\n        uint256 currentAnnualFee = (curatorFee * totalSupply()) / 10000;\n        // get how much that is per second;\n        uint256 feePerSecond = currentAnnualFee / 31536000;\n        // get how many seconds they are eligible to claim\n        uint256 sinceLastClaim = block.timestamp - lastClaimed;\n        // get the amount of tokens to mint\n        uint256 curatorMint = sinceLastClaim * feePerSecond;\n\n        // now lets do the same for governance\n        address govAddress = vaultManager.feeReceiver();\n        uint256 govFee = factory.governanceFee();\n        currentAnnualFee = (govFee * totalSupply()) / 10000;\n        feePerSecond = currentAnnualFee / 31536000;\n        uint256 govMint = sinceLastClaim * feePerSecond;\n\n        lastClaimed = block.timestamp;\n\n        if (curator != address(0)) {\n            _mint(curator, curatorMint);\n            emit CuratorFeeClaimed(curatorMint);\n        }\n        if (govAddress != address(0)) {\n            _mint(govAddress, govMint);\n            emit CuratorFeeClaimed(govMint);\n        }\n    }\n\n    function _getAuctionPrice() internal view returns (uint256) {\n        address priceOracle = vaultManager.priceOracle();\n        bool aboveQuorum = _getQuorum() > factory.minVotePercentage();\n        uint256 _reservePrice = reservePrice();\n\n        if (address(priceOracle) != address(0)) {\n            (, uint256 reserve1,) = pair.getReserves();\n\n            bool aboveLiquidityThreshold = reserve1 * 2 > factory.liquidityThreshold();\n\n            if (aboveLiquidityThreshold) {\n                uint256 twapPrice = _getTWAP();\n                if (aboveQuorum) {\n                    //twap price if twap > reserve\n                    //reserve price if twap < reserve\n                    return twapPrice > _reservePrice ? twapPrice : _reservePrice;\n                } else {\n                    //twap price if twap > initial reserve\n                    //reserve price if twap < initial reserve\n                    return twapPrice > initialReserve ? twapPrice : initialReserve;\n                }\n            } else {\n                if (aboveQuorum) {\n                    //average reserve\n                    return _reservePrice;\n                } else {\n                    //initial reserve\n                    return initialReserve;\n                }\n            }\n        } else {\n            return aboveQuorum ? _reservePrice : initialReserve;\n        }\n    }\n\n    function _getQuorum() internal view returns (uint256) {\n        IIFO ifo = IIFO(IIFOFactory(vaultManager.ifoFactory()).ifos(address(this)));\n        if (address(ifo) != address(0) && ifo.ended() && ifo.fnftLocked()) {\n            return votingTokens * 10000 / (totalSupply() - ifo.lockedSupply());\n        } else {\n            return votingTokens * 10000 / totalSupply();\n        }\n    }\n\n    function _getTWAP() internal view returns (uint256) {\n        try IPriceOracle(vaultManager.priceOracle()).getFNFTPriceETH(address(this), totalSupply()) returns (uint256 twapPrice) {\n            return twapPrice;\n        } catch {\n            return 0;\n        }\n    }\n\n    function _onlyOwnerIfPaused(uint256 lockId) internal view {\n        if (msg.sender != owner() && IPausable(address(factory)).isPaused(lockId)) revert Paused();\n    }\n\n    function _onlyPrivileged() internal view {\n        if (curator == address(0)) {\n            if (msg.sender != owner()) revert NotOwner();\n        } else {\n            if (msg.sender != curator) revert NotCurator();\n        }\n    }\n\n    // Will attempt to transfer ETH, but will transfer WETH instead if it fails.\n    function _sendETHOrWETH(address to, uint256 value) internal {\n        // Try to transfer ETH to the given recipient.\n        if (!_attemptETHTransfer(to, value)) {\n            // If the transfer fails, wrap and send as WETH, so that\n            // the auction is not impeded and the recipient still\n            // can claim ETH via the WETH contract (similar to escrow).\n            IWETH weth = IWETH(vaultManager.WETH());\n            weth.deposit{value: value}();\n            weth.transfer(to, value);\n            // At this point, the recipient can unwrap WETH.\n        }\n    }\n\n    /// @notice makes sure that the new price does not impact the reserve drastically\n    function _validateUserPrice(uint256 prevUserReserve, uint256 newUserReserve) private view {\n        uint256 reservePriceMin = (prevUserReserve * factory.minReserveFactor()) / 10000;\n        if (newUserReserve < reservePriceMin) revert PriceTooLow();\n        uint256 reservePriceMax = (prevUserReserve * factory.maxReserveFactor()) / 10000;\n        if (newUserReserve > reservePriceMax) revert PriceTooHigh();\n    }\n\n    function _chargeAndDistributeFees(address user, uint256 amount) internal override virtual {\n        if (amount == 0) {\n            return;\n        }\n\n        // Mint fees directly to the distributor and distribute.\n        address feeDistributor = vaultManager.feeDistributor();\n        // Changed to a _transfer() in v1.0.3.\n        super._transfer(user, feeDistributor, amount);\n        // IFeeDistributor(feeDistributor).distribute(vaultId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "src/contracts/interfaces/IIFO.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IFNFT.sol\";\nimport \"./IIFOFactory.sol\";\n\ninterface IIFO {\n    struct UserInfo {\n        uint256 amount; // Amount ETH deposited by user\n        uint256 debt; // total FNFT claimed thus FNFT debt\n    }\n\n    function curator() external view returns (address);\n\n    function factory() external view returns (IIFOFactory);\n\n    function fnft() external view returns (IFNFT);\n\n    function amountForSale() external view returns (uint256);\n\n    function price() external view returns (uint256);\n\n    function cap() external view returns (uint256);\n\n    function totalRaised() external view returns (uint256);\n\n    function profitRaised() external view returns (uint256);\n\n    function totalSold() external view returns (uint256);\n\n    function lockedSupply() external view returns (uint256);\n\n    function duration() external view returns (uint256);\n\n    function startBlock() external view returns (uint256);\n\n    function pauseBlock() external view returns (uint256);\n\n    function allowWhitelisting() external view returns (bool);\n\n    function started() external view returns (bool);\n\n    function ended() external view returns (bool);\n\n    function paused() external view returns (bool);\n\n    function userInfo(address) external view returns (uint256, uint256);\n\n    function whitelisted(address) external view returns (bool);\n\n    function __IFO_init(\n        address _curator,\n        address _fnftAddress,\n        uint256 _amountForSale,\n        uint256 _price,\n        uint256 _cap,\n        uint256 _duration,\n        bool _allowWhitelisting\n    ) external;\n\n    function addWhitelist(address _address) external;\n\n    function addMultipleWhitelists(address[] calldata _addresses) external;\n\n    function removeWhitelist(address _address) external;\n\n    function start() external;\n\n    function togglePause() external returns (bool);\n\n    function end() external;\n\n    function deposit() external payable;\n\n    function getUserRemainingAllocation(address _user) external view returns (uint256);\n\n    function updateFNFTAddress(address _address) external;\n\n    function adminWithdrawProfit() external;\n\n    function adminWithdrawFNFT() external;\n\n    function approve() external;\n\n    function emergencyWithdrawFNFT() external;\n\n    function fnftLocked() external view returns (bool);\n\n    event FNFTSold(address indexed buyer, uint256 amount, uint256 payout);\n    event SaleStarted();\n    event SaleEnded();\n    event PausedToggled(bool paused);\n    event AdminProfitWithdrawn(address FNFT, uint256 amount);\n    event AdminFNFTWithdrawn(address FNFT, uint256 amount);\n    event EmergencyFNFTWithdrawn(address FNFT, uint256 amount);\n\n    error ContractPaused();\n    error DeadlineActive();\n    error FNFTLocked();\n    error InvalidAmountForSale();\n    error InvalidCap();\n    error InvalidDuration();\n    error InvalidPrice();\n    error InvalidReservePrice();\n    error NoLiquidityProvided();\n    error NoProfit();\n    error NotCurator();\n    error NotEnoughSupply();\n    error NotGov();\n    error NotWhitelisted();\n    error OverLimit();\n    error SaleActive();\n    error SaleAlreadyEnded();\n    error SaleAlreadyStarted();\n    error SaleUnstarted();\n    error TooManyWhitelists();\n    error TxFailed();\n    error WhitelistingDisallowed();\n    error ZeroAddress();\n}\n"
    },
    "src/contracts/interfaces/IIFOFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IIFOFactory {\n    function ifos(address) external view returns (address);\n\n    function minimumDuration() external view returns (uint256);\n\n    function maximumDuration() external view returns (uint256);\n\n    function governanceFee() external view returns (uint256);\n\n    function creatorUtilityContract() external view returns (address);\n\n    function creatorIFOLock() external view returns (bool);\n\n    function feeReceiver() external view returns (address payable);\n\n    function __IFOFactory_init() external;\n\n    function create(\n        address _fnft,\n        uint256 _amountForSale,\n        uint256 _price,\n        uint256 _cap,\n        uint256 _duration,\n        bool _allowWhitelisting\n    ) external returns (address);\n\n    function pause() external;\n\n    function unpause() external;\n\n    function setCreatorIFOLock(bool _creatorIFOLock) external;\n\n    function setMinimumDuration(uint256 _minimumDuration) external;\n\n    function setMaximumDuration(uint256 _maximumDuration) external;\n\n    function setCreatorUtilityContract(address _creatorUtilityContract) external;\n\n    function setGovernanceFee(uint256 _governanceFee) external;\n\n    function setFeeReceiver(address payable _feeReceiver) external;\n\n    event CreatorIFOLockUpdated(bool oldCreatorIFOLock, bool newCreatorIFOLock);\n    event MinimumDurationUpdated(uint256 oldMinimumDuration, uint256 newMinimumDuration);\n    event MaximumDurationUpdated(uint256 oldMaximumDuration, uint256 newMaximumDuration);\n    event CreatorUtilityContractUpdated(address oldCreatorUtilityContract, address newCreatorUtilityContract);\n    event GovernanceFeeUpdated(uint256 oldGovernanceFee, uint256 newGovernanceFee);\n    event FeeReceiverUpdated(address oldFeeReceiver, address newFeeReceiver);\n    event IFOCreated(\n        address indexed ifo,\n        address indexed fnft,\n        uint256 amountForSale,\n        uint256 price,\n        uint256 cap,\n        uint256 duration,\n        bool allowWhitelisting\n    );\n\n    error FeeTooHigh();\n    error IFOExists(address nft);\n    error InvalidDuration();\n    error ZeroAddress();\n}\n"
    },
    "src/contracts/interfaces/IFNFTSingle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashBorrowerUpgradeable.sol\";\n\nimport \"./IVaultManager.sol\";\nimport \"./IUniswapV2Pair.sol\";\nimport \"./IFNFTSingleFactory.sol\";\nimport \"../token/ERC20Upgradeable.sol\";\n\ninterface IFNFTSingle  is IERC20Upgradeable {\n    enum State {\n        Inactive,\n        Live,\n        Ended,\n        Redeemed\n    }\n\n    function token() external returns (address);\n\n    function winning() external returns (address payable);\n\n    function vaultId() external returns (uint256);\n\n    function tokenId() external returns (uint256);\n\n    function auctionEnd() external returns (uint256);\n\n    function auctionLength() external returns (uint256);\n\n    function reserveTotal() external returns (uint256);\n\n    function livePrice() external returns (uint256);\n\n    function pair() external returns (IUniswapV2Pair);\n\n    function auctionState() external returns (State);\n\n    function factory() external returns (IFNFTSingleFactory);\n\n    function vaultManager() external returns (IVaultManager);\n\n    function verified() external returns (bool);\n\n    function curator() external returns (address);\n\n    function curatorFee() external returns (uint256);\n\n    function lastClaimed() external returns (uint256);\n\n    function votingTokens() external returns (uint256);\n\n    function initialReserve() external returns (uint256);\n\n    function userReservePrice(address) external returns (uint256);\n\n    function __FNFTSingle_init(\n        string memory _name,\n        string memory _symbol,\n        address _curator,\n        address _token,\n        uint256 _id,\n        uint256 _supply,\n        uint256 _listPrice,\n        uint256 _curatorFee\n    ) external;\n\n    function reservePrice() external view returns (uint256);\n\n    function kickCurator(address _curator) external;\n\n    function removeReserve(address _user) external;\n\n    function toggleVerified() external;\n\n    function setCurator(address _curator) external;\n\n    function setAuctionLength(uint256 _length) external;\n\n    function setFee(uint256 _fee) external;\n\n    function claimCuratorFees() external;\n\n    function getAuctionPrice() external view returns (uint256);\n\n    function buyItNow() external payable;\n\n    function buyItNowPrice() external view returns (uint256);\n\n    function updateUserPrice(uint256 newUserReserve) external;\n\n    function getQuorum() external view returns (uint256);\n\n    function start() external payable;\n\n    function bid() external payable;\n\n    function end() external;\n\n    function redeem() external;\n\n    function cash() external;\n\n    function flashFee(address borrowedToken, uint256 amount) external view returns (uint256);\n\n    function flashLoan(\n        IERC3156FlashBorrowerUpgradeable receiver,\n        address borrowedToken,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n\n    function setVaultMetadata(\n        string calldata name_,\n        string calldata symbol_\n    ) external;\n\n    /// @notice An event emitted when a user updates their price\n    event PriceUpdated(address indexed user, uint256 price);\n    /// @notice An event emitted when an auction starts\n    event AuctionStarted(address indexed buyer, uint256 price);\n    /// @notice An event emitted when a bid is made\n    event BidMade(address indexed buyer, uint256 price);\n    /// @notice An event emitted when an auction is won\n    event AuctionWon(address indexed buyer, uint256 price);\n    /// @notice An event emitted when someone redeems all tokens for the NFT\n    event TokenRedeemed(address indexed redeemer);\n    /// @notice An event emitted when someone cashes in ERC20 tokens for ETH from an ERC721 token sale\n    event CashWithdrawn(address indexed owner, uint256 shares);\n    event AuctionLengthUpdated(uint256 length);\n    event CuratorFeeUpdated(uint256 curatorFee);\n    event CuratorFeeClaimed(uint256 curatorFee);\n    event Verified(bool verified);\n    event CuratorKicked(address indexed oldCurator, address indexed newCurator);\n    event CuratorUpdated(address indexed oldCurator, address indexed newCurator);\n\n    error AuctionEnded();\n    error AuctionLive();\n    error AuctionNotEnded();\n    error AuctionNotLive();\n    error BidTooLow();\n    error CanNotRaise();\n    error FeeTooHigh();\n    error InvalidAuctionLength();\n    error NotAnUpdate();\n    error NotCurator();\n    error NotEnoughETH();\n    error NotEnoughVoters();\n    error NotOwner();\n    error NoTokens();\n    error Paused();\n    error PriceTooHigh();\n    error PriceTooLow();\n    error SameCurator();\n    error InvalidToken();\n    error ZeroAddress();\n}"
    },
    "src/contracts/interfaces/IFNFTSingleFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport {IPriceOracle} from \"./IPriceOracle.sol\";\nimport {IWETH} from \"./IWETH.sol\";\nimport {IVaultManager} from \"./IVaultManager.sol\";\n\ninterface IFNFTSingleFactory {\n    function vaultManager() external view returns (IVaultManager);\n\n    function maxAuctionLength() external view returns (uint256);\n\n    function minAuctionLength() external view returns (uint256);\n\n    function maxCuratorFee() external view returns (uint256);\n\n    function governanceFee() external view returns (uint256);\n\n    function minBidIncrease() external view returns (uint256);\n\n    function minVotePercentage() external view returns (uint256);\n\n    function maxReserveFactor() external view returns (uint256);\n\n    function minReserveFactor() external view returns (uint256);\n\n    function liquidityThreshold() external view returns (uint256);\n\n    function instantBuyMultiplier() external view returns (uint256);\n\n    function __FNFTSingleFactory_init(address _vaultManager, address _fnftSingle) external;\n\n    function createVault(\n        address _nft,\n        uint256 _tokenId,\n        uint256 _supply,\n        uint256 _listPrice,\n        uint256 _fee,\n        string memory _name,\n        string memory _symbol\n    ) external returns (address);\n\n    function flashLoanFee() external view returns (uint256);\n\n    function setFactoryFees(\n        uint256 _governanceFee,\n        uint256 _maxCuratorFee,\n        uint256 _flashLoanFee\n    ) external;\n\n    function setFactoryThresholds(\n        uint256 _maxAuctionLength,\n        uint256 _minAuctionLength,\n        uint256 _minReserveFactor,\n        uint256 _maxReserveFactor,\n        uint256 _minBidIncrease,\n        uint256 _minVotePercentage,\n        uint256 _liquidityThreshold,\n        uint256 _instantBuyMultiplier\n    ) external;\n\n    event FactoryFeesUpdated(uint256 governanceFee, uint256 maxCuratorFee, uint256 flashLoanFee);\n    event FactoryThresholdsUpdated(\n        uint256 maxAuctionLength,\n        uint256 minAuctionLength,\n        uint256 minReserveFactor,\n        uint256 maxReserveFactor,\n        uint256 minBidIncrease,\n        uint256 minVotePercentage,\n        uint256 liquidityThreshold,\n        uint256 instantBuyMultiplier\n    );\n    event FeeExclusionUpdated(address target, bool excluded);\n    event VaultCreated(\n        uint256 indexed vaultId,\n        address curator,\n        address vaultAddress,\n        address assetAddress,\n        uint256 tokenId,\n        uint256 supply,\n        uint256 listPrice,\n        string name,\n        string symbol\n    );\n    event VaultCurated(\n        address vaultAddress,\n        address curator,\n        uint256 supply,\n        uint256 listPrice,\n        uint256 fee\n    );\n\n    error FeeTooHigh();\n    error MaxAuctionLengthOutOfBounds();\n    error MinAuctionLengthOutOfBounds();\n    error MinBidIncreaseOutOfBounds();\n    error MinReserveFactorTooHigh();\n    error MaxReserveFactorTooLow();\n    error MinVotePercentageTooHigh();\n    error MultiplierTooLow();\n    error ZeroAddress();\n}\n"
    },
    "src/contracts/interfaces/IWETH.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n\n    function approve(address, uint256) external returns (bool);\n\n    function transfer(address, uint256) external returns (bool);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "src/contracts/interfaces/IFNFT.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IVaultManager.sol\";\nimport \"./IUniswapV2Pair.sol\";\n\ninterface IFNFT {\n    function vaultId() external returns (uint256);\n\n    function pair() external returns (IUniswapV2Pair);\n\n    function factory() external returns (address);\n\n    function vaultManager() external returns (IVaultManager);\n\n    function verified() external returns (bool);\n\n    function setVaultMetadata(\n        string calldata name_,\n        string calldata symbol_\n    ) external;\n\n    //ERC20 Interface\n\n    function decimals() external returns (uint8);\n\n    function balanceOf(address _account) external returns (uint256);\n\n    function totalSupply() external returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}"
    },
    "src/contracts/LPStakingZap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IFeeDistributor.sol\";\nimport \"./interfaces/ILPStaking.sol\";\nimport \"./interfaces/ILPStakingZap.sol\";\nimport \"./interfaces/IUniswapV2Router.sol\";\nimport \"./interfaces/IVaultManager.sol\";\nimport \"./interfaces/IWETH.sol\";\n\ncontract LPStakingZap is ILPStakingZap, Ownable, ReentrancyGuard {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  IUniswapV2Router public immutable override router;\n  IVaultManager public immutable override vaultManager;\n  IWETH public immutable override WETH;\n\n  ILPStaking public override lpStaking;\n\n  uint256 public override lpLockTime = 48 hours;\n\n  constructor(address _vaultManager, address _router) Ownable() ReentrancyGuard() {\n    router = IUniswapV2Router(_router);\n    vaultManager = IVaultManager(_vaultManager);\n    WETH = IWETH(IUniswapV2Router(_router).WETH());\n    IERC20Upgradeable(address(IUniswapV2Router(_router).WETH())).safeApprove(_router, type(uint256).max);\n  }\n\n  function assignLPStakingContract() public override {\n    if (address(lpStaking) != address(0)) revert NotZeroAddress();\n    IFeeDistributor feeDistributor = IFeeDistributor(IVaultManager(vaultManager).feeDistributor());\n    lpStaking = ILPStaking(feeDistributor.lpStaking());\n  }\n\n  receive() external payable {\n    if (msg.sender != address(WETH)) revert OnlyWETH();\n  }\n\n  function rescue(address token) external override onlyOwner {\n    if (token == address(0)) {\n      (bool success, ) = payable(msg.sender).call{value: address(this).balance}(\"\");\n      if (!success) revert CallFailed();\n    } else {\n      IERC20Upgradeable(token).safeTransfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n  }\n\n  function setLPLockTime(uint256 _lpLockTime) external override onlyOwner {\n    if (_lpLockTime > 7 days) revert LockTooLong();\n    emit LPLockTimeUpdated(lpLockTime, _lpLockTime);\n    lpLockTime = _lpLockTime;\n  }\n\n\tfunction stakeLiquidityETH(\n\t\tuint256 vaultId,\n    uint256 minTokenIn,\n    uint256 wethIn,\n    address to\n\t) external payable override nonReentrant returns (uint256, uint256, uint256) {\n\t\tif (to == address(0) || to == address(this)) revert InvalidDestination();\n\t\tWETH.deposit{value: msg.value}();\n\n    address vault = vaultManager.vault(vaultId);\n\n\t\treturn _addLiquidityAndLock(vaultId, vault, minTokenIn, msg.value, wethIn, to);\n\t}\n\n\tfunction stakeLiquidityWETH(\n\t\tuint256 vaultId,\n    uint256 minTokenIn,\n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n\t) external override nonReentrant returns (uint256, uint256, uint256) {\n\t\tif (to == address(0) || to == address(this)) revert InvalidDestination();\n\t\tIERC20Upgradeable(address(WETH)).safeTransferFrom(msg.sender, address(this), wethIn);\n\n    address vault = vaultManager.vault(vaultId);\n\n\t\treturn _addLiquidityAndLock(vaultId, vault, minTokenIn, minWethIn, wethIn, to);\n\t}\n\n  function unlockAndRemoveLiquidityETH(\n    uint256 vaultId,\n    uint256 amount,\n    uint256 minTokenOut,\n    uint256 minEthOut,\n    address to\n  ) external override returns (uint256, uint256) {\n    IVaultManager _vaultManager = vaultManager;\n    if (to == address(0) || to == address(this)) revert InvalidDestination();\n    if (!_vaultManager.excludedFromFees(address(this))) revert NotExcluded();\n\n    address vault = _vaultManager.vault(vaultId);\n\n    lpStaking.claimRewardsTo(vaultId, to);\n    lpStaking.withdrawTo(vaultId, amount, address(this));\n\n    (uint256 amountToken, uint256 amountEth) = router.removeLiquidityETH(\n      vault,\n      amount,\n      minTokenOut,\n      minEthOut,\n      to,\n      block.timestamp\n    );\n\n    return (amountToken, amountEth);\n  }\n\n  function unlockAndRemoveLiquidityWETH(\n    uint256 vaultId,\n    uint256 amount,\n    uint256 minTokenOut,\n    uint256 minEthOut,\n    address to\n  ) external override returns (uint256, uint256) {\n    IVaultManager _vaultManager = vaultManager;\n    if (to == address(0) || to == address(this)) revert InvalidDestination();\n    if (!_vaultManager.excludedFromFees(address(this))) revert NotExcluded();\n\n    address vault = _vaultManager.vault(vaultId);\n\n    lpStaking.claimRewardsTo(vaultId, to);\n    lpStaking.withdrawTo(vaultId, amount, address(this));\n\n    (uint256 amountToken, uint256 amountWeth) = router.removeLiquidity(\n      vault,\n      address(WETH),\n      amount,\n      minTokenOut,\n      minEthOut,\n      to,\n      block.timestamp\n    );\n\n    return (amountToken, amountWeth);\n  }\n\n\tfunction _addLiquidityAndLock(\n\t\tuint256 vaultId,\n    address vault,\n    uint256 minTokenIn,\n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n\t) internal returns (uint256, uint256, uint256) {\n\t\tif (!vaultManager.excludedFromFees(address(this))) revert NotExcluded();\n\n\t\t// Provide liquidity.\n    IERC20Upgradeable(vault).safeApprove(address(router), minTokenIn);\n\n\t\t(uint256 amountToken, uint256 amountEth, uint256 liquidity) = router.addLiquidity(\n      vault,\n      address(WETH),\n      minTokenIn,\n      wethIn,\n      minTokenIn,\n      minWethIn,\n      address(this),\n      block.timestamp\n    );\n\n\t\t// Stake in LP rewards contract\n    address lpToken = _pairFor(vault, address(WETH));\n    IERC20Upgradeable(lpToken).safeApprove(address(lpStaking), liquidity);\n    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);\n\n\t\tuint256 remaining = minTokenIn-amountToken;\n    if (remaining != 0) {\n      IERC20Upgradeable(vault).safeTransfer(to, remaining);\n    }\n\n\t\tuint256 lockEndTime = block.timestamp + lpLockTime;\n    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);\n    return (amountToken, amountEth, liquidity);\n\t}\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function _pairFor(address tokenA, address tokenB) internal view returns (address pair) {\n    (address token0, address token1) = _sortTokens(tokenA, tokenB);\n    pair = address(uint160(uint256(keccak256(abi.encodePacked(\n      hex'ff',\n      router.factory(),\n      keccak256(abi.encodePacked(token0, token1)),\n      hex'754e1d90e536e4c1df81b7f030f47b4ca80c87120e145c294f098c83a6cb5ace' // init code hash\n    )))));\n  }\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function _sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n    if (tokenA == tokenB) revert IdenticalAddress();\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    if (token0 == address(0)) revert ZeroAddress();\n  }\n}"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "src/contracts/interfaces/ILPStakingZap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./IWETH.sol\";\nimport \"./ILPStaking.sol\";\nimport \"./IVaultManager.sol\";\nimport \"./IUniswapV2Router.sol\";\n\ninterface ILPStakingZap {\n    function WETH() external returns(IWETH);\n\n    function vaultManager() external returns(IVaultManager);\n\n    function router() external returns(IUniswapV2Router);\n\n    function lpStaking() external returns(ILPStaking);\n\n    function lpLockTime() external returns(uint256);\n\n    function assignLPStakingContract() external;\n\n    function rescue(address token) external;\n\n    function setLPLockTime(uint256 _lpLockTime) external;\n\n    function stakeLiquidityETH(\n\t\tuint256 vaultId,\n        uint256 minTokenIn,\n        uint256 wethIn,\n        address to\n\t) external payable returns (uint256, uint256, uint256);\n\n    function stakeLiquidityWETH(\n\t\tuint256 vaultId,\n        uint256 minTokenIn,\n        uint256 minWethIn,\n        uint256 wethIn,\n        address to\n\t) external returns (uint256, uint256, uint256);\n\n    function unlockAndRemoveLiquidityETH(\n        uint256 vaultId,\n        uint256 amount,\n        uint256 minTokenOut,\n        uint256 minEthOut,\n        address to\n    ) external returns (uint256, uint256);\n\n    function unlockAndRemoveLiquidityWETH(\n        uint256 vaultId,\n        uint256 amount,\n        uint256 minTokenOut,\n        uint256 minEthOut,\n        address to\n    ) external returns (uint256, uint256);\n\n    event UserStaked(uint256 indexed vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address indexed sender);\n    event LPLockTimeUpdated(uint256 oldLockTime, uint256 newLockTime);\n\n    error CallFailed();\n    error IdenticalAddress();\n    error InvalidDestination();\n    error LockTooLong();\n    error NotExcluded();\n    error NotZeroAddress();\n    error OnlyWETH();\n    error ZeroAddress();\n}\n"
    },
    "src/contracts/interfaces/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Router {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n}"
    },
    "src/contracts/VaultManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport \"./interfaces/IVaultManager.sol\";\nimport \"./interfaces/IFeeDistributor.sol\";\n\ncontract VaultManager is\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    IVaultManager\n{\n    mapping(address => bool) public override excludedFromFees;\n\n    address[] public override vaults;\n\n    address public override feeDistributor;\n\n    /// @notice the address who receives auction fees\n    address payable public override feeReceiver;\n\n    address public override fnftSingleFactory;\n\n    address public override fnftCollectionFactory;\n\n    address public override ifoFactory;\n\n    address public override priceOracle;\n\n    address public override zapContract;\n\n    address public override WETH;\n\n    function __VaultManager_init(\n        address _weth,\n        address _ifoFactory,\n        address _priceOracle\n    ) external override initializer {\n        __Ownable_init();\n        __Pausable_init();\n        WETH = _weth;\n        ifoFactory = _ifoFactory;\n        priceOracle = _priceOracle;\n        feeReceiver = payable(msg.sender);\n    }\n\n    function addVault(address _fnft) external override returns (uint256 vaultId) {\n        if (_fnft == address(0)) revert ZeroAddress();\n        address _feeDistributor = feeDistributor;\n        if (_feeDistributor == address(0)) revert ZeroAddress();\n        if (msg.sender != fnftCollectionFactory && msg.sender != fnftSingleFactory) revert OnlyFactory();\n        vaultId = vaults.length;\n        vaults.push(_fnft);\n        IFeeDistributor(_feeDistributor).initializeVaultReceivers(vaultId);\n        emit VaultAdded(vaultId, _fnft);\n    }\n\n    function numVaults() external view override returns (uint) {\n        return vaults.length;\n    }\n\n    function setFeeDistributor(address _feeDistributor) public override onlyOwner {\n        if (_feeDistributor == address(0)) revert ZeroAddress();\n        emit FeeDistributorUpdated(feeDistributor, _feeDistributor);\n        feeDistributor = _feeDistributor;\n    }\n\n    function setFeeReceiver(address payable _feeReceiver) external override onlyOwner {\n        if (_feeReceiver == address(0)) revert ZeroAddress();\n        emit FeeReceiverUpdated(feeReceiver, _feeReceiver);\n        feeReceiver = _feeReceiver;\n    }\n\n    function setFNFTCollectionFactory(address _fnftCollectionFactory) external override onlyOwner {\n        if (_fnftCollectionFactory == address(0)) revert ZeroAddress();\n        emit FNFTCollectionFactoryUpdated(fnftCollectionFactory, _fnftCollectionFactory);\n        fnftCollectionFactory = _fnftCollectionFactory;\n    }\n\n    function setFNFTSingleFactory(address _fnftSingleFactory) external override onlyOwner {\n        if (_fnftSingleFactory == address(0)) revert ZeroAddress();\n        emit FNFTSingleFactoryUpdated(fnftSingleFactory, _fnftSingleFactory);\n        fnftSingleFactory = _fnftSingleFactory;\n    }\n\n    function setPriceOracle(address _priceOracle) external override onlyOwner {\n        emit PriceOracleUpdated(priceOracle, _priceOracle);\n        priceOracle = _priceOracle;\n    }\n\n    function setZapContract(address _zapContract) external override onlyOwner {\n        if (_zapContract == address(0)) revert ZeroAddress();\n        emit ZapContractUpdated(zapContract, _zapContract);\n        zapContract = _zapContract;\n    }\n\n    function togglePaused() external override onlyOwner {\n        paused() ? _unpause() : _pause();\n    }\n\n    function vault(uint256 vaultId) external view override returns (address) {\n        return vaults[vaultId];\n    }\n\n    function setFeeExclusion(address _address, bool _excluded) public override onlyOwner {\n        emit FeeExclusionUpdated(_address, _excluded);\n        excludedFromFees[_address] = _excluded;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "src/contracts/interfaces/IStakingZap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./IWETH.sol\";\nimport \"./ILPStaking.sol\";\nimport \"./IFNFTStaking.sol\";\nimport \"./IVaultManager.sol\";\nimport \"./IUniswapV2Router.sol\";\n\ninterface IStakingZap {\n    function WETH() external returns(IWETH);\n\n    function vaultManager() external returns(IVaultManager);\n\n    function router() external returns(IUniswapV2Router);\n\n    function lpStaking() external returns(ILPStaking);\n\n    function fnftStaking() external returns(IFNFTStaking);\n\n    function lpLockTime() external returns(uint256);\n\n    function inventoryLockTime() external returns(uint256);\n\n    function assignStakingContracts() external;\n\n    function setLPLockTime(uint256 _lpLockTime) external;\n\n    function setInventoryLockTime(uint256 _inventoryLockTime) external;\n\n    function provideInventory721(uint256 vaultId, uint256[] calldata tokenIds) external;\n\n    function provideInventory1155(uint256 vaultId, uint256[] calldata tokenIds, uint256[] calldata amounts) external;\n\n    function addLiquidity721ETH(\n        uint256 vaultId,\n        uint256[] calldata ids,\n        uint256 minWethIn\n    ) external payable returns (uint256);\n\n    function addLiquidity721ETHTo(\n        uint256 vaultId,\n        uint256[] memory ids,\n        uint256 minWethIn,\n        address to\n    ) external payable returns (uint256);\n\n    function addLiquidity1155ETH(\n        uint256 vaultId,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        uint256 minEthIn\n    ) external payable returns (uint256);\n\n    function addLiquidity1155ETHTo(\n        uint256 vaultId,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        uint256 minEthIn,\n        address to\n    ) external payable returns (uint256);\n\n    function addLiquidity721(\n        uint256 vaultId,\n        uint256[] calldata ids,\n        uint256 minWethIn,\n        uint256 wethIn\n    ) external returns (uint256);\n\n    function addLiquidity721To(\n        uint256 vaultId,\n        uint256[] memory ids,\n        uint256 minWethIn,\n        uint256 wethIn,\n        address to\n    ) external returns (uint256);\n\n    function addLiquidity1155(\n        uint256 vaultId,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        uint256 minWethIn,\n        uint256 wethIn\n    ) external returns (uint256);\n\n    function addLiquidity1155To(\n        uint256 vaultId,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        uint256 minWethIn,\n        uint256 wethIn,\n        address to\n    ) external returns (uint256);\n\n    function rescue(address token) external;\n\n    event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);\n    event InventoryLockTimeUpdated(uint256 oldLockTime, uint256 newLockTime);\n    event LPLockTimeUpdated(uint256 oldLockTime, uint256 newLockTime);\n\n    error CallFailed();\n    error CallFailedWithMessage(string message);\n    error IdenticalAddress();\n    error InvalidAmount();\n    error InvalidDestination();\n    error LockTooLong();\n    error NotEqualLength();\n    error NotExcluded();\n    error NotOwner();\n    error NotZeroAddress();\n    error OnlyWETH();\n    error ZeroAddress();\n}\n"
    },
    "src/contracts/LPStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\nimport \"./interfaces/ILPStaking.sol\";\nimport \"./interfaces/IStakingTokenProvider.sol\";\nimport \"./interfaces/IVaultManager.sol\";\nimport \"./token/LPStakingXTokenUpgradeable.sol\";\nimport \"./util/Pausable.sol\";\n\n// Pausing codes for LP staking are:\n// 10: Deposit\n\ncontract LPStaking is ILPStaking, Pausable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    mapping(uint256 => StakingPool) public override vaultStakingInfo;\n\n    IStakingTokenProvider public override stakingTokenProvider;\n    LPStakingXTokenUpgradeable public override lpStakingXToken;\n    IVaultManager public override vaultManager;\n\n    function __LPStaking__init(address _vaultManager, address _stakingTokenProvider) external override initializer {\n        __Ownable_init();\n        if (_stakingTokenProvider == address(0)) revert ZeroAddress();\n        if (address(lpStakingXToken) != address(0)) revert LPStakingXTokenAlreadySet();\n        vaultManager = IVaultManager(_vaultManager);\n        stakingTokenProvider = IStakingTokenProvider(_stakingTokenProvider);\n        lpStakingXToken = new LPStakingXTokenUpgradeable();\n        lpStakingXToken.__LPStakingXToken_init(IERC20Upgradeable(address(0)), \"\", \"\");\n    }\n\n    modifier onlyAdmin() {\n        if (msg.sender != owner() && msg.sender != vaultManager.feeDistributor()) revert Unauthorized();\n        _;\n    }\n\n    function addPoolForVault(uint256 vaultId) external override onlyAdmin {\n        if (address(vaultManager) == address(0)) revert VaultManagerNotSet();\n        if (vaultStakingInfo[vaultId].stakingToken != address(0)) revert PoolAlreadyExists();\n        address _baseToken = vaultManager.vault(vaultId);\n        address _stakingToken = stakingTokenProvider.stakingTokenForVaultToken(_baseToken);\n        StakingPool memory pool = StakingPool(_stakingToken, _baseToken);\n        vaultStakingInfo[vaultId] = pool;\n        address newXToken = _deployDividendToken(pool);\n        emit StakingPoolCreated(vaultId, newXToken, _baseToken);\n    }\n\n    function deposit(uint256 vaultId, uint256 amount) external override {\n        onlyOwnerIfPaused(10);\n        // Check the pool in case its been updated.\n        updatePoolForVault(vaultId);\n\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        if (pool.stakingToken == address(0)) revert PoolDoesNotExist();\n        IERC20Upgradeable(pool.stakingToken).safeTransferFrom(msg.sender, address(this), amount);\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\n\n        // If the user has an existing timelock, check if it is in the future.\n        uint256 currentTimelock = _xToken.timelockUntil(msg.sender);\n        if (currentTimelock > block.timestamp) {\n            // Maintain the same timelock if they already have one.\n            // We do this instead of patching in the token because\n            // the reward distribution token contracts as currently deployed are not upgradeable.\n            _xToken.timelockMint(msg.sender, amount, currentTimelock-block.timestamp);\n        } else {\n            // Timelock for 2 seconds if they don't already have a timelock to prevent flash loans.\n            _xToken.timelockMint(msg.sender, amount, 2);\n        }\n\n        emit LPDeposited(vaultId, amount, address(_xToken), msg.sender);\n    }\n\n    function claimMultipleRewards(uint256[] calldata vaultIds) external override {\n        uint256 length = vaultIds.length;\n        for (uint256 i; i < length;) {\n            claimRewardsTo(vaultIds[i], msg.sender);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function emergencyExit(address _stakingToken, address _baseToken) external override {\n        StakingPool memory pool = StakingPool(_stakingToken, _baseToken);\n        LPStakingXTokenUpgradeable dist = xToken(pool);\n        if (!_isContract(address(dist))) revert NotAPool();\n        _withdraw(pool, dist.balanceOf(msg.sender), msg.sender);\n    }\n\n    function emergencyExitAndClaim(address _stakingToken, address _baseToken) external override {\n        StakingPool memory pool = StakingPool(_stakingToken, _baseToken);\n        LPStakingXTokenUpgradeable dist = xToken(pool);\n        if (!_isContract(address(dist))) revert NotAPool();\n        _claimRewards(pool, msg.sender);\n        _withdraw(pool, dist.balanceOf(msg.sender), msg.sender);\n    }\n\n    function exit(uint256 vaultId) external override {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        _claimRewards(pool, msg.sender);\n        _withdraw(pool, balanceOf(vaultId, msg.sender), msg.sender);\n    }\n\n    function lockedLPBalance(uint256 vaultId, address who) external view override returns (uint256) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\n        if(block.timestamp > _xToken.timelockUntil(who)) {\n            return 0;\n        }\n        return _xToken.balanceOf(who);\n    }\n\n    function lockedUntil(uint256 vaultId, address who) external view override returns (uint256) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\n        return _xToken.timelockUntil(who);\n    }\n\n    function receiveRewards(uint256 vaultId, uint256 amount) external override onlyAdmin returns (bool) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        if (pool.stakingToken == address(0)) {\n            // In case the pair is updated, but not yet\n            return false;\n        }\n\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\n        // Don't distribute rewards unless there are people to distribute to.\n        // Also added here if the distribution token is not deployed, just forfeit rewards for now.\n        if (!_isContract(address(_xToken)) || _xToken.totalSupply() == 0) {\n            return false;\n        }\n        // We \"pull\" to the dividend tokens so the vault only needs to approve this contract.\n        IERC20Upgradeable(pool.baseToken).safeTransferFrom(msg.sender, address(_xToken), amount);\n        _xToken.distributeRewards(amount);\n        emit FeesReceived(vaultId, amount, address(_xToken));\n        return true;\n    }\n\n    function xToken(uint256 vaultId) external view override returns (LPStakingXTokenUpgradeable) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        if (pool.stakingToken == address(0)) {\n            return LPStakingXTokenUpgradeable(address(0));\n        }\n        return xToken(pool);\n    }\n\n    function setStakingTokenProvider(address _stakingTokenProvider) external override onlyOwner {\n        if (_stakingTokenProvider == address(0)) revert ZeroAddress();\n        emit StakingTokenProviderUpdated(address(stakingTokenProvider), _stakingTokenProvider);\n        stakingTokenProvider = IStakingTokenProvider(_stakingTokenProvider);\n    }\n\n    function timelockDepositFor(uint256 vaultId, address account, uint256 amount, uint256 timelockLength) external override {\n        if (timelockLength >= 2592000) revert TimelockTooLong();\n        if (!vaultManager.excludedFromFees(msg.sender)) revert NotExcludedFromFees();\n        onlyOwnerIfPaused(10);\n        // Check the pool in case its been updated.\n        updatePoolForVault(vaultId);\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        if (pool.stakingToken == address(0)) revert PoolDoesNotExist();\n        IERC20Upgradeable(pool.stakingToken).safeTransferFrom(msg.sender, address(this), amount);\n        xToken(pool).timelockMint(account, amount, timelockLength);\n    }\n\n    // In case the provider changes, this lets the pool be updated. Anyone can call it.\n    function updatePoolForVault(uint256 vaultId) public override {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        // Not letting people use this function to create new pools.\n        if (pool.stakingToken == address(0)) revert PoolDoesNotExist();\n        address _stakingToken = stakingTokenProvider.stakingTokenForVaultToken(pool.baseToken);\n        StakingPool memory newPool = StakingPool(_stakingToken, pool.baseToken);\n        vaultStakingInfo[vaultId] = newPool;\n\n        // If the pool is already deployed, ignore the update.\n        address addr = address(xToken(newPool));\n        if (_isContract(addr)) {\n            return;\n        }\n        address newXToken = _deployDividendToken(newPool);\n        emit StakingPoolUpdated(vaultId, newXToken);\n    }\n\n    function updatePoolForVaults(uint256[] calldata vaultIds) external override {\n        uint256 length = vaultIds.length;\n        for (uint256 i; i < length;) {\n            updatePoolForVault(vaultIds[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function withdrawTo(uint256 vaultId, uint256 amount, address to) external override {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        _claimRewards(pool, to);\n        _withdraw(pool, amount, to);\n\n        emit XTokenWithdrawn(vaultId, amount, address(xToken(pool)), to);\n    }\n\n    function balanceOf(uint256 vaultId, address addr) public view override returns (uint256) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\n        if (!_isContract(address(_xToken))) revert NotAPool();\n        return _xToken.balanceOf(addr);\n    }\n\n    function claimRewardsTo(uint256 vaultId, address to) public override {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        _claimRewards(pool, to);\n    }\n\n    // Note: this function does not guarantee the token is deployed, we leave that check to elsewhere to save gas.\n    function xToken(StakingPool memory pool) public view override returns (LPStakingXTokenUpgradeable) {\n        bytes32 salt = keccak256(abi.encodePacked(pool.stakingToken, pool.baseToken, uint256(2) /* small nonce to change tokens */));\n        address tokenAddr = ClonesUpgradeable.predictDeterministicAddress(address(lpStakingXToken), salt);\n        return LPStakingXTokenUpgradeable(tokenAddr);\n    }\n\n    function xTokenAddr(address stakedToken, address baseToken) public view override returns (address) {\n        StakingPool memory pool = StakingPool(stakedToken, baseToken);\n        return address(xToken(pool));\n    }\n\n    function retrieveTokens(uint256 vaultId, uint256 amount, address from, address to) public override onlyOwner {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\n        _xToken.burnFrom(from, amount);\n        _xToken.mint(to, amount);\n    }\n\n    function _claimRewards(StakingPool memory pool, address account) internal {\n        if (pool.stakingToken == address(0)) revert PoolDoesNotExist();\n        xToken(pool).withdrawReward(account);\n    }\n\n    function _deployDividendToken(StakingPool memory pool) internal returns (address) {\n        // Changed to use new nonces.\n        bytes32 salt = keccak256(abi.encodePacked(pool.stakingToken, pool.baseToken, uint256(2)));\n        address _xToken = ClonesUpgradeable.cloneDeterministic(address(lpStakingXToken), salt);\n        string memory name = stakingTokenProvider.nameForStakingToken(pool.baseToken);\n        LPStakingXTokenUpgradeable(_xToken).__LPStakingXToken_init(IERC20Upgradeable(pool.baseToken), name, name);\n        return _xToken;\n    }\n\n    function _isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    function _withdraw(StakingPool memory pool, uint256 amount, address account) internal {\n        if (pool.stakingToken == address(0)) revert PoolDoesNotExist();\n        xToken(pool).burnFrom(account, amount);\n        IERC20Upgradeable(pool.stakingToken).safeTransfer(account, amount);\n    }\n}"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Create2.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) internal pure returns (address) {\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\n        return address(uint160(uint256(_data)));\n    }\n}\n"
    },
    "src/contracts/util/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract Pausable is OwnableUpgradeable {\n\n    function __Pausable_init() internal initializer {\n        __Ownable_init();\n    }\n\n    event SetIsGuardian(address addr, bool isGuardian);\n    event SetPaused(uint256 lockId, bool paused);\n\n    mapping(address => bool) public isGuardian;\n    mapping(uint256 => bool) public isPaused;\n    // 0  : createVault\n    // 1  : mint\n    // 2  : redeem\n    // 3  : swap\n    // 4  : auction\n    // 5  : flashloan\n    // 6  : fee\n    // 7  : price\n    // 10 : stake\n\n    error Paused();\n    error Unauthorized();\n\n    function onlyOwnerIfPaused(uint256 lockId) public view virtual {\n        if (isPaused[lockId] && msg.sender != owner()) revert Paused();\n    }\n\n    function pause(uint256 lockId) public virtual {\n        if (!isGuardian[msg.sender]) revert Unauthorized();\n        isPaused[lockId] = true;\n        emit SetPaused(lockId, true);\n    }\n\n    function setIsGuardian(address _address, bool _isGuardian) public virtual onlyOwner {\n        isGuardian[_address] = _isGuardian;\n        emit SetIsGuardian(_address, _isGuardian);\n    }\n\n    function unpause(uint256 lockId)\n        public\n        virtual\n        onlyOwner\n    {\n        isPaused[lockId] = false;\n        emit SetPaused(lockId, false);\n    }\n}\n"
    },
    "src/contracts/proxy/Deployer.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../FNFTSingleFactory.sol\";\nimport \"../IFOFactory.sol\";\nimport \"../PriceOracle.sol\";\nimport \"../VaultManager.sol\";\nimport \"../FNFTCollectionFactory.sol\";\nimport \"../FeeDistributor.sol\";\nimport \"../FNFTStaking.sol\";\nimport \"../LPStaking.sol\";\nimport \"../StakingTokenProvider.sol\";\nimport \"./AdminUpgradeabilityProxy.sol\";\nimport \"./IMultiProxyController.sol\";\nimport \"../interfaces/IOwnable.sol\";\n\ncontract Deployer is Ownable {\n    event ProxyDeployed(\n        bytes32 indexed identifier,\n        address logic,\n        address creator\n    );\n\n    error NoController();\n\n    IMultiProxyController public proxyController;\n\n    bytes32 constant public FNFT_SINGLE_FACTORY = bytes32(0x464e465453696e676c65466163746f7279000000000000000000000000000000);\n    bytes32 constant public IFO_FACTORY = bytes32(0x49464f466163746f727900000000000000000000000000000000000000000000);\n    bytes32 constant public PRICE_ORACLE = bytes32(0x50726963654f7261636c65000000000000000000000000000000000000000000);\n    bytes32 constant public FNFT_COLLECTION_FACTORY = bytes32(0x464e4654436f6c6c656374696f6e466163746f72790000000000000000000000);\n    bytes32 constant public VAULT_MANAGER = bytes32(0x5661756c744d616e616765720000000000000000000000000000000000000000);\n    bytes32 constant public FEE_DISTRIBUTOR = bytes32(0x4665654469737472696275746f72000000000000000000000000000000000000);\n    bytes32 constant public INVENTORY_STAKING = bytes32(0x496e76656e746f72795374616b696e6700000000000000000000000000000000);\n    bytes32 constant public LP_STAKING = bytes32(0x4c505374616b696e670000000000000000000000000000000000000000000000);\n    bytes32 constant public STAKING_TOKEN_PROVIDER = bytes32(0x5374616b696e67546f6b656e50726f7669646572000000000000000000000000);\n\n    // Gov\n\n    function setProxyController(address _proxyController) external onlyOwner {\n        proxyController = IMultiProxyController(_proxyController);\n    }\n\n    /// @notice the function to deploy IFOFactory\n    /// @param _logic the implementation\n    function deployIFOFactory(\n        address _logic\n    ) external onlyOwner returns (address ifoFactory) {\n        if (address(proxyController) == address(0)) revert NoController();\n\n        bytes memory _initializationCalldata = abi.encodeWithSelector(IFOFactory.__IFOFactory_init.selector);\n\n        ifoFactory = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\n        IIFOFactory(ifoFactory).setFeeReceiver(payable(msg.sender));\n        IOwnable(ifoFactory).transferOwnership(msg.sender);\n\n        proxyController.deployerUpdateProxy(IFO_FACTORY, ifoFactory);\n\n        emit ProxyDeployed(IFO_FACTORY, ifoFactory, msg.sender);\n    }\n\n    /// @notice the function to deploy PriceOracle\n    /// @param _logic the implementation\n    function deployPriceOracle(address _logic) external onlyOwner returns (address priceOracle) {\n        if (address(proxyController) == address(0)) revert NoController();\n\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\n            PriceOracle.__PriceOracle_init.selector\n        );\n\n        priceOracle = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\n        IOwnable(priceOracle).transferOwnership(msg.sender);\n\n        proxyController.deployerUpdateProxy(PRICE_ORACLE, priceOracle);\n\n        emit ProxyDeployed(PRICE_ORACLE, priceOracle, msg.sender);\n    }\n\n    /// @notice the function to deploy FeeDistributor\n    /// @param _logic the implementation\n    function deployFeeDistributor(address _logic, address vaultManager, address lpStaking, address treasury) external onlyOwner returns (address feeDistributor) {\n        if (address(proxyController) == address(0)) revert NoController();\n\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\n            FeeDistributor.__FeeDistributor_init.selector,\n            vaultManager,\n            lpStaking,\n            treasury\n        );\n\n        feeDistributor = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\n        IOwnable(feeDistributor).transferOwnership(msg.sender);\n\n        proxyController.deployerUpdateProxy(FEE_DISTRIBUTOR, feeDistributor);\n\n        emit ProxyDeployed(FEE_DISTRIBUTOR, feeDistributor, msg.sender);\n    }\n\n    /// @notice the function to deploy FNFTCollectionFactory\n    /// @param _logic the implementation\n    function deployVaultManager(\n        address _logic,\n        address _weth,\n        address _ifoFactory,\n        address _priceOracle\n    ) external onlyOwner returns (address vaultManager) {\n        if (address(proxyController) == address(0)) revert NoController();\n\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\n            VaultManager.__VaultManager_init.selector,\n            _weth,\n            _ifoFactory,\n            _priceOracle\n        );\n\n        vaultManager = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\n        IOwnable(vaultManager).transferOwnership(msg.sender);\n\n        proxyController.deployerUpdateProxy(VAULT_MANAGER, vaultManager);\n\n        emit ProxyDeployed(VAULT_MANAGER, vaultManager, msg.sender);\n    }\n\n    /// @notice the function to deploy FNFTSingleFactory\n    /// @param _logic the implementation\n    /// @param _vaultManager variable needed for FNFTSingleFactory\n    function deployFNFTSingleFactory(\n        address _logic,\n        address _vaultManager,\n        address _fnftSingle\n    ) external onlyOwner returns (address fnftSingleFactory) {\n        if (address(proxyController) == address(0)) revert NoController();\n\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\n            FNFTSingleFactory.__FNFTSingleFactory_init.selector,\n            _vaultManager,\n            _fnftSingle\n        );\n\n        fnftSingleFactory = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\n        IOwnable(fnftSingleFactory).transferOwnership(msg.sender);\n\n        proxyController.deployerUpdateProxy(FNFT_SINGLE_FACTORY, fnftSingleFactory);\n\n        emit ProxyDeployed(FNFT_SINGLE_FACTORY, fnftSingleFactory, msg.sender);\n    }\n\n    /// @notice the function to deploy FNFTCollectionFactory\n    /// @param _logic the implementation\n    /// @param _vaultManager variable needed for FNFTCollectionFactory\n    function deployFNFTCollectionFactory(\n        address _logic,\n        address _vaultManager,\n        address _fnftCollection\n    ) external onlyOwner returns (address factory) {\n        if (address(proxyController) == address(0)) revert NoController();\n\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\n            FNFTCollectionFactory.__FNFTCollectionFactory_init.selector,\n            _vaultManager,\n            _fnftCollection\n        );\n\n        factory = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\n        IOwnable(factory).transferOwnership(msg.sender);\n\n        proxyController.deployerUpdateProxy(FNFT_COLLECTION_FACTORY, factory);\n\n        emit ProxyDeployed(FNFT_COLLECTION_FACTORY, factory, msg.sender);\n    }\n\n    /// @notice the function to deploy LPStaking\n    /// @param _logic the implementation\n    function deployLPStaking(address _logic, address vaultManager, address stakingTokenProvider) external onlyOwner returns (address lpStaking) {\n        if (address(proxyController) == address(0)) revert NoController();\n\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\n            LPStaking.__LPStaking__init.selector,\n            vaultManager,\n            stakingTokenProvider\n        );\n\n        lpStaking = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\n        IOwnable(lpStaking).transferOwnership(msg.sender);\n\n        proxyController.deployerUpdateProxy(LP_STAKING, lpStaking);\n\n        emit ProxyDeployed(LP_STAKING, lpStaking, msg.sender);\n    }\n\n    /// @notice the function to deploy FNFTStaking\n    /// @param _logic the implementation\n    function deployFNFTStaking(address _logic, address fnftCollectionFactory) external onlyOwner returns (address fnftStaking) {\n        if (address(proxyController) == address(0)) revert NoController();\n\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\n            FNFTStaking.__FNFTStaking_init.selector,\n            fnftCollectionFactory\n        );\n\n        fnftStaking = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\n        IOwnable(fnftStaking).transferOwnership(msg.sender);\n\n        proxyController.deployerUpdateProxy(INVENTORY_STAKING, fnftStaking);\n\n        emit ProxyDeployed(INVENTORY_STAKING, fnftStaking, msg.sender);\n    }\n\n    /// @notice the function to deploy StakingTokenProvider\n    /// @param _logic the implementation\n    function deployStakingTokenProvider(address _logic, address uniswapV2Factory, address defaultPairedToken, string memory defaultPrefix) external onlyOwner returns (address stakingTokenProvider) {\n        if (address(proxyController) == address(0)) revert NoController();\n\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\n            StakingTokenProvider.__StakingTokenProvider_init.selector,\n            uniswapV2Factory,\n            defaultPairedToken,\n            defaultPrefix\n        );\n\n        stakingTokenProvider = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\n        IOwnable(stakingTokenProvider).transferOwnership(msg.sender);\n\n        proxyController.deployerUpdateProxy(STAKING_TOKEN_PROVIDER, stakingTokenProvider);\n\n        emit ProxyDeployed(STAKING_TOKEN_PROVIDER, stakingTokenProvider, msg.sender);\n    }\n}\n"
    },
    "src/contracts/FNFTSingleFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport \"./interfaces/IFNFTSingleFactory.sol\";\nimport \"./interfaces/IFNFTSingle.sol\";\nimport \"./interfaces/IOwnable.sol\";\nimport \"./interfaces/IVaultManager.sol\";\nimport \"./proxy/BeaconProxy.sol\";\nimport \"./proxy/BeaconUpgradeable.sol\";\nimport \"./util/Pausable.sol\";\n\ncontract FNFTSingleFactory is\n    IFNFTSingleFactory,\n    Pausable,\n    BeaconUpgradeable\n{\n    IVaultManager public override vaultManager;\n\n    /// @notice flash loan fee basis point\n    uint256 public override flashLoanFee;\n\n    /// @notice governance fee max\n    uint256 public override governanceFee;\n\n    /// @notice instant buy allowed if bid > MC * instantBuyMultiplier\n    uint256 public override instantBuyMultiplier;\n\n    /// @notice minimum size of FNFT-ETH LP pool for TWAP to take effect\n    uint256 public override liquidityThreshold;\n\n    /// @notice the maximum auction length\n    uint256 public override maxAuctionLength;\n\n    /// @notice max curator fee\n    uint256 public override maxCuratorFee;\n\n    /// @notice the max % increase over the initial\n    uint256 public override maxReserveFactor;\n\n    /// @notice the minimum auction length\n    uint256 public override minAuctionLength;\n\n    /// @notice the % bid increase required for a new bid\n    uint256 public override minBidIncrease;\n\n    /// @notice the max % decrease from the initial\n    uint256 public override minReserveFactor;\n\n    /// @notice the % of tokens required to be voting for an auction to start\n    uint256 public override minVotePercentage;\n\n    function __FNFTSingleFactory_init(address _vaultManager, address _fnftSingle) external override initializer {\n        if (_vaultManager == address(0)) revert ZeroAddress();\n        if (_fnftSingle == address(0)) revert ZeroAddress();\n        __Pausable_init();\n        __BeaconUpgradeable__init(_fnftSingle);\n        vaultManager = IVaultManager(_vaultManager);\n        maxAuctionLength = 2 weeks;\n        minAuctionLength = 3 days;\n        minReserveFactor = 2000; // 20%\n        maxReserveFactor = 50000; // 500%\n        minBidIncrease = 500; // 5%\n        maxCuratorFee = 1000;\n        minVotePercentage = 2500; // 25%\n        liquidityThreshold = 30e18; // ~$30,000 USD in ETH\n        instantBuyMultiplier = 15; // instant buy allowed if 1.5x MC\n    }\n\n    /// @notice the function to mint a fnftSingle\n    /// @param _nft the ERC721 token address\n    /// @param _tokenId the uint256 id of the token\n    /// @param _supply vault token supply\n    /// @param _listPrice the initial price of the NFT\n    /// @param _fee curator fee\n    /// @param _name the desired name of the vault\n    /// @param _symbol the desired symbol of the vault\n    /// @return vaultId\n    function createVault(\n        address _nft,\n        uint256 _tokenId,\n        uint256 _supply,\n        uint256 _listPrice,\n        uint256 _fee,\n        string memory _name,\n        string memory _symbol\n    ) external virtual override returns (address) {\n        onlyOwnerIfPaused(0);\n        if (childImplementation() == address(0)) revert ZeroAddress();\n        IVaultManager _vaultManager = vaultManager;\n        address fnftSingle = _deployVault(\n            _name,\n            _symbol,\n            _nft,\n            _tokenId,\n            _supply,\n            _listPrice,\n            _fee\n        );\n        uint vaultId = _vaultManager.addVault(fnftSingle);\n        IERC721(_nft).safeTransferFrom(msg.sender, fnftSingle, _tokenId);\n\n        emit VaultCreated(vaultId, msg.sender, fnftSingle, _nft, _tokenId, _supply, _listPrice, _name, _symbol);\n        return fnftSingle;\n    }\n\n    function setFactoryFees(\n        uint256 _governanceFee,\n        uint256 _maxCuratorFee,\n        uint256 _flashLoanFee\n    ) public virtual override onlyOwner {\n        if (_governanceFee > 1000) revert FeeTooHigh();\n        if (_flashLoanFee > 500) revert FeeTooHigh();\n        if (_maxCuratorFee > 2000) revert FeeTooHigh();\n\n        governanceFee = _governanceFee;\n        maxCuratorFee = _maxCuratorFee;\n        flashLoanFee = _flashLoanFee;\n\n        emit FactoryFeesUpdated(_governanceFee, _maxCuratorFee, _flashLoanFee);\n    }\n\n    function setFactoryThresholds(\n        uint256 _maxAuctionLength,\n        uint256 _minAuctionLength,\n        uint256 _minReserveFactor,\n        uint256 _maxReserveFactor,\n        uint256 _minBidIncrease,\n        uint256 _minVotePercentage,\n        uint256 _liquidityThreshold,\n        uint256 _instantBuyMultiplier\n    ) public virtual override onlyOwner {\n        if (_minAuctionLength < 1 days || _minAuctionLength >= maxAuctionLength) revert MinAuctionLengthOutOfBounds();\n        if (_maxAuctionLength > 8 weeks || _maxAuctionLength <= minAuctionLength) revert MaxAuctionLengthOutOfBounds();\n\n        if (_minReserveFactor >= maxReserveFactor) revert MinReserveFactorTooHigh();\n        if (_maxReserveFactor <= minReserveFactor) revert MaxReserveFactorTooLow();\n\n        if (_minBidIncrease > 1000 || _minBidIncrease < 100) revert MinBidIncreaseOutOfBounds();\n        if (_minVotePercentage > 10000) revert MinVotePercentageTooHigh();\n\n        if (_instantBuyMultiplier < 10) revert MultiplierTooLow();\n\n        maxAuctionLength = _maxAuctionLength;\n        minAuctionLength = _minAuctionLength;\n        minReserveFactor = _minReserveFactor;\n        maxReserveFactor = _maxReserveFactor;\n        minBidIncrease = _minBidIncrease;\n        minVotePercentage = _minVotePercentage;\n        liquidityThreshold = _liquidityThreshold;\n        instantBuyMultiplier = _instantBuyMultiplier;\n\n        emit FactoryThresholdsUpdated(\n            _maxAuctionLength,\n            _minAuctionLength,\n            _minReserveFactor,\n            _maxReserveFactor,\n            _minBidIncrease,\n            _minVotePercentage,\n            _liquidityThreshold,\n            _instantBuyMultiplier\n        );\n    }\n\n    /// @dev 0x86a777ab == FNFTSingle.__FNFTSingle_init.selector\n    function _deployVault(\n        string memory _name,\n        string memory _symbol,\n        address _nft,\n        uint256 _tokenId,\n        uint256 _supply,\n        uint256 _listPrice,\n        uint256 _fee\n    ) internal returns (address) {\n        // bytes memory _initializationCalldata = abi.encodeWithSelector(\n        //     0x86a777ab,\n        //     _name,\n        //     _symbol,\n        //     msg.sender,\n        //     _nft,\n        //     _tokenId,\n        //     _supply,\n        //     _listPrice,\n        //     _fee\n        // );\n\n        // address newBeaconProxy = address(new BeaconProxy(address(this), _initializationCalldata));\n\n        // // Owner for administrative functions.\n        // IOwnable(newBeaconProxy).transferOwnership(owner());\n\n        // return newBeaconProxy;\n\n        address newBeaconProxy = address(new BeaconProxy(address(this), \"\"));\n        IFNFTSingle(newBeaconProxy).__FNFTSingle_init(\n            _name, _symbol, msg.sender, _nft, _tokenId, _supply, _listPrice, _fee\n        );\n        // Owner for administrative functions.\n        // IOwnable(newBeaconProxy).transferOwnership(owner());\n        return newBeaconProxy;\n    }\n}\n"
    },
    "src/contracts/IFOFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IFO.sol\";\nimport \"./interfaces/IIFOFactory.sol\";\nimport \"./proxy/BeaconProxy.sol\";\nimport \"./proxy/BeaconUpgradeable.sol\";\n\ncontract IFOFactory is IIFOFactory, OwnableUpgradeable, PausableUpgradeable, BeaconUpgradeable {\n    /// @notice 10% fee is max\n    uint256 public constant MAX_GOV_FEE = 1000;\n\n    /// @notice the mapping of FNFT to IFO address\n    mapping(address => address) public override ifos;\n\n    address public override creatorUtilityContract;\n    /// @notice the address who receives ifo fees\n    address payable public override feeReceiver;\n    /// @notice the boolean whether creator should have access to the creator's FNFT shares after IFO\n    bool public override creatorIFOLock;\n\n    uint256 public override governanceFee;\n    uint256 public override maximumDuration;\n    uint256 public override minimumDuration;\n\n    function __IFOFactory_init() external override initializer {\n        __Ownable_init();\n        __Pausable_init();\n        __BeaconUpgradeable__init(address(new IFO()));\n\n        feeReceiver = payable(msg.sender);\n        governanceFee = 200;\n        maximumDuration = 7776000; // 90 days;\n        minimumDuration = 86400; // 1 day;\n    }\n\n    /// @notice the function to create an IFO\n    /// @param _fnft the ERC20 token address of the FNFT\n    /// @param _amountForSale the amount of FNFT for sale in IFO\n    /// @param _price the price of each FNFT token\n    /// @param _cap the maximum amount an account can buy\n    /// @param _allowWhitelisting if IFO should be governed by whitelists\n    /// @return IFO address\n    function create(\n        address _fnft,\n        uint256 _amountForSale,\n        uint256 _price,\n        uint256 _cap,\n        uint256 _duration,\n        bool _allowWhitelisting\n    ) external override whenNotPaused returns (address) {\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\n            IFO.__IFO_init.selector,\n            msg.sender,\n            _fnft,\n            _amountForSale,\n            _price,\n            _cap,\n            _duration,\n            _allowWhitelisting\n        );\n\n        address _ifo = address(new BeaconProxy(address(this), _initializationCalldata));\n        ifos[_fnft] = _ifo;\n\n        IERC20(_fnft).transferFrom(msg.sender, _ifo, IERC20(_fnft).balanceOf(msg.sender));\n\n        emit IFOCreated(_ifo, _fnft, _amountForSale, _price, _cap, _duration, _allowWhitelisting);\n\n        return _ifo;\n    }\n\n    function pause() external override onlyOwner {\n        _pause();\n    }\n\n    function setCreatorIFOLock(bool _creatorIFOLock) external override onlyOwner {\n        emit CreatorIFOLockUpdated(creatorIFOLock, _creatorIFOLock);\n        creatorIFOLock = _creatorIFOLock;\n    }\n\n    function setCreatorUtilityContract(address _creatorUtilityContract) external override onlyOwner {\n        emit CreatorUtilityContractUpdated(creatorUtilityContract, _creatorUtilityContract);\n        creatorUtilityContract = _creatorUtilityContract;\n    }\n\n    function setFeeReceiver(address payable _feeReceiver) external override onlyOwner {\n        if (_feeReceiver == address(0)) revert ZeroAddress();\n        emit FeeReceiverUpdated(feeReceiver, _feeReceiver);\n        feeReceiver = _feeReceiver;\n    }\n\n    function setGovernanceFee(uint256 _governanceFee) external override onlyOwner {\n        if (_governanceFee > MAX_GOV_FEE) revert FeeTooHigh();\n        emit GovernanceFeeUpdated(governanceFee, _governanceFee);\n        governanceFee = _governanceFee;\n    }\n\n    function setMaximumDuration(uint256 _maximumDuration) external override onlyOwner {\n        if (minimumDuration > _maximumDuration) revert InvalidDuration();\n        emit MaximumDurationUpdated(maximumDuration, _maximumDuration);\n        maximumDuration = _maximumDuration;\n    }\n\n    function setMinimumDuration(uint256 _minimumDuration) external override onlyOwner {\n        if (_minimumDuration > maximumDuration) revert InvalidDuration();\n        emit MinimumDurationUpdated(minimumDuration, _minimumDuration);\n        minimumDuration = _minimumDuration;\n    }\n\n    function unpause() external override onlyOwner {\n        _unpause();\n    }\n}\n"
    },
    "src/contracts/FNFTCollectionFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./interfaces/IFNFTCollectionFactory.sol\";\nimport \"./interfaces/IFNFTCollection.sol\";\nimport \"./interfaces/IOwnable.sol\";\nimport \"./interfaces/IVaultManager.sol\";\nimport \"./proxy/BeaconProxy.sol\";\nimport \"./proxy/BeaconUpgradeable.sol\";\nimport \"./util/Pausable.sol\";\n\n// Authors: @0xKiwi_ and @alexgausman.\n\ncontract FNFTCollectionFactory is\n    IFNFTCollectionFactory,\n    Pausable,\n    BeaconUpgradeable\n{\n    mapping(uint256 => VaultFees) private _vaultFees;\n\n    uint64 public override factoryMintFee;\n    uint64 public override factoryRandomRedeemFee;\n    uint64 public override factoryRandomSwapFee;\n    uint64 public override factoryTargetRedeemFee;\n\n    IVaultManager public override vaultManager;\n    uint64 public override factoryTargetSwapFee;\n\n    address public override eligibilityManager;\n    uint256 public override flashLoanFee;\n\n    /// @notice the maximum auction length\n    uint256 public override maxAuctionLength;\n\n    /// @notice the minimum auction length\n    uint256 public override minAuctionLength;\n\n    /// @notice the % bid increase required for a new bid\n    uint256 public override minBidIncrease;\n\n    function __FNFTCollectionFactory_init(address _vaultManager, address _fnftCollection) external override initializer {\n        if (_vaultManager == address(0)) revert ZeroAddress();\n        if (_fnftCollection == address(0)) revert ZeroAddress();\n        __Pausable_init();\n        __BeaconUpgradeable__init(_fnftCollection);\n        vaultManager = IVaultManager(_vaultManager);\n        factoryMintFee = uint64(0.1 ether);\n        factoryRandomRedeemFee = uint64(0.05 ether);\n        factoryTargetRedeemFee = uint64(0.1 ether);\n        factoryRandomSwapFee = uint64(0.05 ether);\n        factoryTargetSwapFee = uint64(0.1 ether);\n        maxAuctionLength = 2 weeks;\n        minAuctionLength = 3 days;\n        minBidIncrease = 500; // 5%\n    }\n\n    function createVault(\n        address _assetAddress,\n        bool is1155,\n        bool allowAllItems,\n        string memory _name,\n        string memory _symbol\n    ) external virtual override returns (address) {\n        onlyOwnerIfPaused(0);\n        if (childImplementation() == address(0)) revert ZeroAddress();\n        IVaultManager _vaultManager = vaultManager;\n        address fnftCollection = _deployVault(_name, _symbol, _assetAddress, is1155, allowAllItems);\n        uint vaultId = _vaultManager.addVault(fnftCollection);\n        emit VaultCreated(vaultId, msg.sender, fnftCollection, _assetAddress, _name, _symbol);\n        return fnftCollection;\n    }\n\n    function setEligibilityManager(address _eligibilityManager) external virtual override onlyOwner {\n        emit EligibilityManagerUpdated(eligibilityManager, _eligibilityManager);\n        eligibilityManager = _eligibilityManager;\n    }\n\n    function vaultFees(uint256 vaultId) external view virtual override returns (uint256, uint256, uint256, uint256, uint256) {\n        VaultFees memory fees = _vaultFees[vaultId];\n        if (fees.active) {\n            return (\n                uint256(fees.mintFee),\n                uint256(fees.randomRedeemFee),\n                uint256(fees.targetRedeemFee),\n                uint256(fees.randomSwapFee),\n                uint256(fees.targetSwapFee)\n            );\n        }\n\n        return (uint256(factoryMintFee), uint256(factoryRandomRedeemFee), uint256(factoryTargetRedeemFee), uint256(factoryRandomSwapFee), uint256(factoryTargetSwapFee));\n    }\n\n    function disableVaultFees(uint256 vaultId) public virtual override {\n        if (msg.sender != owner()) {\n            address vaultAddr = vaultManager.vault(vaultId);\n            if (msg.sender != vaultAddr) revert NotVault();\n        }\n        delete _vaultFees[vaultId];\n        emit VaultFeesDisabled(vaultId);\n    }\n\n    function setFactoryFees(\n        uint256 _factoryMintFee,\n        uint256 _factoryRandomRedeemFee,\n        uint256 _factoryTargetRedeemFee,\n        uint256 _factoryRandomSwapFee,\n        uint256 _factoryTargetSwapFee,\n        uint256 _flashLoanFee\n    ) public virtual override onlyOwner {\n        if (_factoryMintFee > 0.5 ether) revert FeeTooHigh();\n        if (_factoryRandomRedeemFee > 0.5 ether) revert FeeTooHigh();\n        if (_factoryTargetRedeemFee > 0.5 ether) revert FeeTooHigh();\n        if (_factoryRandomSwapFee > 0.5 ether) revert FeeTooHigh();\n        if (_factoryTargetSwapFee > 0.5 ether) revert FeeTooHigh();\n        if (_flashLoanFee > 500) revert FeeTooHigh();\n\n        factoryMintFee = uint64(_factoryMintFee);\n        factoryRandomRedeemFee = uint64(_factoryRandomRedeemFee);\n        factoryTargetRedeemFee = uint64(_factoryTargetRedeemFee);\n        factoryRandomSwapFee = uint64(_factoryRandomSwapFee);\n        factoryTargetSwapFee = uint64(_factoryTargetSwapFee);\n        flashLoanFee = _flashLoanFee;\n\n        emit FactoryFeesUpdated(\n            _factoryMintFee,\n            _factoryRandomRedeemFee,\n            _factoryTargetRedeemFee,\n            _factoryRandomSwapFee,\n            _factoryTargetSwapFee,\n            _flashLoanFee\n        );\n    }\n\n    function setFactoryThresholds(\n        uint256 _maxAuctionLength,\n        uint256 _minAuctionLength,\n        uint256 _minBidIncrease\n    ) public virtual override onlyOwner {\n        if (_minAuctionLength < 1 days || _minAuctionLength >= maxAuctionLength) revert MinAuctionLengthOutOfBounds();\n        if (_maxAuctionLength > 8 weeks || _maxAuctionLength <= minAuctionLength) revert MaxAuctionLengthOutOfBounds();\n\n        if (_minBidIncrease > 1000 || _minBidIncrease < 100) revert MinBidIncreaseOutOfBounds();\n\n        maxAuctionLength = _maxAuctionLength;\n        minAuctionLength = _minAuctionLength;\n        minBidIncrease = _minBidIncrease;\n\n        emit FactoryThresholdsUpdated(_maxAuctionLength, _minAuctionLength, _minBidIncrease);\n    }\n\n    function setVaultFees(\n        uint256 vaultId,\n        uint256 _mintFee,\n        uint256 _randomRedeemFee,\n        uint256 _targetRedeemFee,\n        uint256 _randomSwapFee,\n        uint256 _targetSwapFee\n    ) public virtual override {\n        if (msg.sender != owner()) {\n            address vaultAddr = vaultManager.vault(vaultId);\n            if (msg.sender != vaultAddr) revert NotVault();\n        }\n        if (_mintFee > 0.5 ether) revert FeeTooHigh();\n        if (_randomRedeemFee > 0.5 ether) revert FeeTooHigh();\n        if (_targetRedeemFee > 0.5 ether) revert FeeTooHigh();\n        if (_randomSwapFee > 0.5 ether) revert FeeTooHigh();\n        if (_targetSwapFee > 0.5 ether) revert FeeTooHigh();\n\n        _vaultFees[vaultId] = VaultFees(\n            true,\n            uint64(_mintFee),\n            uint64(_randomRedeemFee),\n            uint64(_targetRedeemFee),\n            uint64(_randomSwapFee),\n            uint64(_targetSwapFee)\n        );\n        emit VaultFeesUpdated(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);\n    }\n\n    /// @dev 0x042f186c == FNFTCollection.__FNFTCollection_init.selector\n    function _deployVault(\n        string memory _name,\n        string memory _symbol,\n        address _assetAddress,\n        bool _is1155,\n        bool _allowAllItems\n    ) internal returns (address) {\n        // bytes memory _initializationCalldata = abi.encodeWithSelector(\n        //     0x042f186c,\n        //     name,\n        //     symbol,\n        //     msg.sender,\n        //     _assetAddress,\n        //     is1155,\n        //     allowAllItems\n        // );\n\n        // address newBeaconProxy = address(new BeaconProxy(address(this), _initializationCalldata));\n\n        // // Owner for administrative functions.\n        // IOwnable(newBeaconProxy).transferOwnership(owner());\n\n        // return newBeaconProxy;\n\n        address newBeaconProxy = address(new BeaconProxy(address(this), \"\"));\n        IFNFTCollection(newBeaconProxy).__FNFTCollection_init(\n            _name, _symbol, msg.sender, _assetAddress, _is1155, _allowAllItems\n        );\n        // Owner for administrative functions.\n        IOwnable(newBeaconProxy).transferOwnership(owner());\n        return newBeaconProxy;\n    }\n}"
    },
    "src/contracts/FeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"./interfaces/IFNFTStaking.sol\";\nimport \"./interfaces/IFeeDistributor.sol\";\nimport \"./interfaces/ILPStaking.sol\";\nimport \"./interfaces/IVaultManager.sol\";\nimport \"./util/Pausable.sol\";\n\ncontract FeeDistributor is IFeeDistributor, ReentrancyGuardUpgradeable, Pausable {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  FeeReceiver[] public override feeReceivers;\n\n  IFNFTStaking public override fnftStaking;\n  ILPStaking public override lpStaking;\n  IVaultManager public override vaultManager;\n  address public override treasury;\n\n  // Total allocation points per vault.\n  uint256 public override allocTotal;\n  bool public override distributionPaused;\n\n  function __FeeDistributor_init(address _vaultManager, address _lpStaking, address _treasury) external override initializer {\n    __Pausable_init();\n\n    vaultManager = IVaultManager(_vaultManager);\n\n    setTreasuryAddress(_treasury);\n    setLPStakingAddress(_lpStaking);\n\n    _addReceiver(0.8 ether, _lpStaking, true);\n  }\n\n  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {\n    _addReceiver(_allocPoint, _receiver, _isContract);\n  }\n\n  function distribute(uint256 vaultId) external override virtual nonReentrant {\n    IVaultManager _vaultManager = vaultManager;\n    if (address(_vaultManager) == address(0)) revert ZeroAddress();\n    address _vault = _vaultManager.vault(vaultId);\n\n    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n\n    if (distributionPaused || allocTotal == 0) {\n      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);\n      return;\n    }\n\n    uint256 length = feeReceivers.length;\n    uint256 leftover;\n    for (uint256 i; i < length;) {\n      FeeReceiver memory _feeReceiver = feeReceivers[i];\n      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);\n      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;\n      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);\n      if (!complete) {\n        uint256 remaining = IERC20Upgradeable(_vault).allowance(address(this), _feeReceiver.receiver);\n        IERC20Upgradeable(_vault).safeApprove(_feeReceiver.receiver, 0);\n        leftover = remaining;\n      } else {\n        leftover = 0;\n      }\n      unchecked {\n        ++i;\n      }\n    }\n\n    if (leftover != 0) {\n      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);\n    }\n  }\n\n  function initializeVaultReceivers(uint256 _vaultId) external override {\n    if (msg.sender != address(vaultManager)) revert NotVaultManager();\n    lpStaking.addPoolForVault(_vaultId);\n    IFNFTStaking _inventoryStaking = fnftStaking;\n    if (address(_inventoryStaking) != address(0))\n      _inventoryStaking.deployXTokenForVault(_vaultId);\n  }\n\n  function pauseFeeDistribution(bool _pause) external override onlyOwner {\n    distributionPaused = _pause;\n    emit DistributionPaused(_pause);\n  }\n\n  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {\n    uint256 arrLength = feeReceivers.length;\n    if (_receiverIdx >= arrLength) revert OutOfBounds();\n    emit FeeReceiverRemoved(feeReceivers[_receiverIdx].receiver);\n    allocTotal -= feeReceivers[_receiverIdx].allocPoint;\n    // Copy the last element to what is being removed and remove the last element.\n    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];\n    feeReceivers.pop();\n  }\n\n  function rescueTokens(address _address) external override onlyOwner {\n    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));\n    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);\n  }\n\n  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {\n    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];\n    address oldReceiver = feeReceiver.receiver;\n    feeReceiver.receiver = _address;\n    feeReceiver.isContract = _isContract;\n    emit FeeReceiverAddressUpdated(oldReceiver, _address);\n  }\n\n  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {\n    if(_receiverIdx >= feeReceivers.length) revert OutOfBounds();\n    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];\n    allocTotal -= feeReceiver.allocPoint;\n    feeReceiver.allocPoint = _allocPoint;\n    allocTotal += _allocPoint;\n    emit FeeReceiverAllocUpdated(feeReceiver.receiver, _allocPoint);\n  }\n\n  function setFNFTStakingAddress(address _inventoryStaking) public override onlyOwner {\n    fnftStaking = IFNFTStaking(_inventoryStaking);\n    emit FNFTStakingAddressUpdated(_inventoryStaking);\n  }\n\n  function setLPStakingAddress(address _lpStaking) public override onlyOwner {\n    if (_lpStaking == address(0)) revert ZeroAddress();\n    lpStaking = ILPStaking(_lpStaking);\n    emit LPStakingAddressUpdated(_lpStaking);\n  }\n\n  function setTreasuryAddress(address _treasury) public override onlyOwner {\n    if (_treasury == address(0)) revert ZeroAddress();\n    treasury = _treasury;\n    emit TreasuryAddressUpdated(_treasury);\n  }\n\n  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {\n    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);\n    feeReceivers.push(_feeReceiver);\n    allocTotal += _allocPoint;\n    emit FeeReceiverAdded(_receiver, _allocPoint);\n  }\n\n  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n    if (_receiver.isContract) {\n      IERC20Upgradeable(_vault).safeIncreaseAllowance(_receiver.receiver, amountToSend);\n\n      bytes memory payload = abi.encodeWithSelector(ILPStaking.receiveRewards.selector, _vaultId, amountToSend);\n      (bool success, ) = address(_receiver.receiver).call(payload);\n\n      // If the allowance has not been spent, it means we can pass it forward to next.\n      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;\n    } else {\n      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n      return true;\n    }\n  }\n}"
    },
    "src/contracts/FNFTStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\n\nimport \"./interfaces/IVaultManager.sol\";\nimport \"./interfaces/IFNFTCollection.sol\";\nimport \"./interfaces/IFNFTStaking.sol\";\nimport \"./util/Pausable.sol\";\nimport \"./proxy/BeaconUpgradeable.sol\";\nimport \"./proxy/Create2BeaconProxy.sol\";\nimport \"./token/FNFTStakingXTokenUpgradeable.sol\";\nimport \"./interfaces/ITimelockExcludeList.sol\";\n\n// Author: 0xKiwi.\n\n// Pausing codes for inventory staking are:\n// 10: Deposit\n\ncontract FNFTStaking is IFNFTStaking, Pausable, BeaconUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Small locktime to prevent flash deposits.\n    uint256 internal constant DEFAULT_LOCKTIME = 2;\n    bytes internal constant BEACON_CODE = type(Create2BeaconProxy).creationCode;\n\n    IVaultManager public override vaultManager;\n    ITimelockExcludeList public override timelockExcludeList;\n\n    uint256 public override inventoryLockTimeErc20;\n\n    function __FNFTStaking_init(address _vaultManager) external virtual override initializer {\n        __Ownable_init();\n        vaultManager = IVaultManager(_vaultManager);\n        address xTokenImpl = address(new FNFTStakingXTokenUpgradeable());\n        __BeaconUpgradeable__init(xTokenImpl);\n    }\n\n    modifier onlyAdmin() {\n        if (msg.sender != owner() && msg.sender != vaultManager.feeDistributor()) revert Unauthorized();\n        _;\n    }\n\n    function balanceOf(uint256 vaultId, address who) external view override returns (uint256) {\n        FNFTStakingXTokenUpgradeable xToken = FNFTStakingXTokenUpgradeable(vaultXToken(vaultId));\n        return xToken.balanceOf(who);\n    }\n\n    // Enter staking. Staking, get minted shares and\n    // locks base tokens and mints xTokens.\n    function deposit(uint256 vaultId, uint256 _amount) external virtual override {\n        onlyOwnerIfPaused(10);\n\n        uint256 timelockTime = isAddressTimelockExcluded(msg.sender, vaultId) ? 0 : inventoryLockTimeErc20;\n\n        (IERC20Upgradeable baseToken, FNFTStakingXTokenUpgradeable xToken, uint256 xTokensMinted) = _timelockMintFor(vaultId, msg.sender, _amount, timelockTime);\n        // Lock the base token in the xtoken contract\n        baseToken.safeTransferFrom(msg.sender, address(xToken), _amount);\n        emit BaseTokenDeposited(vaultId, _amount, xTokensMinted, timelockTime, msg.sender);\n    }\n\n    function isAddressTimelockExcluded(address addr, uint256 vaultId) public view override returns (bool) {\n        if (address(timelockExcludeList) == address(0)) {\n            return false;\n        } else {\n            return timelockExcludeList.isExcluded(addr, vaultId);\n        }\n    }\n\n    function receiveRewards(uint256 vaultId, uint256 amount) external virtual override onlyAdmin returns (bool) {\n        address baseToken = vaultManager.vault(vaultId);\n        address deployedXToken = xTokenAddr(address(baseToken));\n\n        // Don't distribute rewards unless there are people to distribute to.\n        // Also added here if the distribution token is not deployed, just forfeit rewards for now.\n        if (!_isContract(deployedXToken) || FNFTStakingXTokenUpgradeable(deployedXToken).totalSupply() == 0) {\n            return false;\n        }\n        // We \"pull\" to the dividend tokens so the fee distributor only needs to approve this contract.\n        IERC20Upgradeable(baseToken).safeTransferFrom(msg.sender, deployedXToken, amount);\n        emit FeesReceived(vaultId, amount, deployedXToken);\n        return true;\n    }\n\n    function setInventoryLockTimeErc20(uint256 _inventoryLockTimeErc20) external override onlyOwner {\n        if (_inventoryLockTimeErc20 > 14 days) revert LockTooLong();\n        emit InventoryLockTimeErc20Updated(inventoryLockTimeErc20, _inventoryLockTimeErc20);\n        inventoryLockTimeErc20 = _inventoryLockTimeErc20;\n    }\n\n    // TODO: timelock exclude list is not yet implemented\n    function setTimelockExcludeList(address _timelockExcludeList) external override onlyOwner {\n        emit TimelockExcludeListUpdated(address(timelockExcludeList), _timelockExcludeList);\n        timelockExcludeList = ITimelockExcludeList(_timelockExcludeList);\n    }\n\n    function timelockMintFor(uint256 vaultId, uint256 amount, address to, uint256 timelockLength) external virtual override returns (uint256) {\n        onlyOwnerIfPaused(10);\n        if (msg.sender != vaultManager.zapContract()) revert NotZapContract();\n        // important for math that staking zap is excluded from fees\n        if (!vaultManager.excludedFromFees(msg.sender)) revert NotExcludedFromFees();\n\n        (, , uint256 xTokensMinted) = _timelockMintFor(vaultId, to, amount, timelockLength);\n        emit BaseTokenDeposited(vaultId, amount, xTokensMinted, timelockLength, to);\n        return xTokensMinted;\n    }\n\n    function timelockUntil(uint256 vaultId, address who) external view override returns (uint256) {\n        FNFTStakingXTokenUpgradeable xToken = FNFTStakingXTokenUpgradeable(vaultXToken(vaultId));\n        return xToken.timelockUntil(who);\n    }\n\n    // Leave the bar. Claim back your tokens.\n    // Unlocks the staked + gained tokens and burns xTokens.\n    function withdraw(uint256 vaultId, uint256 _share) external virtual override {\n        IERC20Upgradeable baseToken = IERC20Upgradeable(vaultManager.vault(vaultId));\n        FNFTStakingXTokenUpgradeable xToken = FNFTStakingXTokenUpgradeable(xTokenAddr(address(baseToken)));\n\n        uint256 baseTokensRedeemed = xToken.burnXTokens(msg.sender, _share);\n        emit XTokenWithdrawn(vaultId, baseTokensRedeemed, _share, msg.sender);\n    }\n\n   function xTokenShareValue(uint256 vaultId) external view virtual override returns (uint256) {\n        IERC20Upgradeable baseToken = IERC20Upgradeable(vaultManager.vault(vaultId));\n        FNFTStakingXTokenUpgradeable xToken = FNFTStakingXTokenUpgradeable(xTokenAddr(address(baseToken)));\n        if (!_isContract(address(xToken))) revert XTokenNotDeployed();\n\n        uint256 multiplier = 10 ** 18;\n        return xToken.totalSupply() > 0\n            ? multiplier * baseToken.balanceOf(address(xToken)) / xToken.totalSupply()\n            : multiplier;\n    }\n\n    function deployXTokenForVault(uint256 vaultId) public virtual override {\n        address baseToken = vaultManager.vault(vaultId);\n        address deployedXToken = xTokenAddr(address(baseToken));\n\n        if (_isContract(deployedXToken)) {\n            return;\n        }\n\n        address xToken = _deployXToken(baseToken);\n        emit StakingPoolCreated(vaultId, xToken, baseToken);\n    }\n\n    function vaultXToken(uint256 vaultId) public view virtual override returns (address) {\n        address baseToken = vaultManager.vault(vaultId);\n        address xToken = xTokenAddr(baseToken);\n        if (!_isContract(xToken)) revert XTokenNotDeployed();\n        return xToken;\n    }\n\n    // Note: this function does not guarantee the token is deployed, we leave that check to elsewhere to save gas.\n    function xTokenAddr(address baseToken) public view virtual override returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(baseToken));\n        address tokenAddr = Create2.computeAddress(salt, keccak256(type(Create2BeaconProxy).creationCode));\n        return tokenAddr;\n    }\n\n    function _deployXToken(address baseToken) internal returns (address) {\n        string memory symbol = IERC20Metadata(baseToken).symbol();\n        symbol = string(abi.encodePacked(\"x\", symbol));\n        bytes32 salt = keccak256(abi.encodePacked(baseToken));\n        address deployedXToken = Create2.deploy(0, salt, BEACON_CODE);\n        FNFTStakingXTokenUpgradeable(deployedXToken).__FNFTStakingXToken_init(baseToken, symbol, symbol);\n        return deployedXToken;\n    }\n\n    function _isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size != 0;\n    }\n\n    function _timelockMintFor(uint256 vaultId, address account, uint256 _amount, uint256 timelockLength) internal returns (IERC20Upgradeable, FNFTStakingXTokenUpgradeable, uint256) {\n        deployXTokenForVault(vaultId);\n        IERC20Upgradeable baseToken = IERC20Upgradeable(vaultManager.vault(vaultId));\n        FNFTStakingXTokenUpgradeable xToken = FNFTStakingXTokenUpgradeable((xTokenAddr(address(baseToken))));\n\n        uint256 xTokensMinted = xToken.mintXTokens(account, _amount, timelockLength);\n        return (baseToken, xToken, xTokensMinted);\n    }\n}\n"
    },
    "src/contracts/StakingTokenProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n// Author: 0xKiwi.\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IStakingTokenProvider.sol\";\n\ncontract StakingTokenProvider is IStakingTokenProvider, OwnableUpgradeable {\n  mapping(address => string) public override pairedPrefix;\n  mapping(address => address) public override pairedToken;\n\n  address public override defaultPairedToken;\n  address public override uniLikeExchange;\n\n  string public override defaultPrefix;\n\n  // This is an address provder to allow us to abstract out what liquidity\n  // our vault tokens should be paired with.\n  function __StakingTokenProvider_init(address _uniLikeExchange, address _defaultPairedtoken, string memory _defaultPrefix) public override initializer {\n    __Ownable_init();\n    if (_uniLikeExchange == address(0)) revert ZeroAddress();\n    if (_defaultPairedtoken == address(0)) revert ZeroAddress();\n    uniLikeExchange = _uniLikeExchange;\n    defaultPairedToken = _defaultPairedtoken;\n    defaultPrefix = _defaultPrefix;\n  }\n\n  function nameForStakingToken(address _vaultToken) external view override returns (string memory) {\n    string memory _pairedPrefix = pairedPrefix[_vaultToken];\n    if (bytes(_pairedPrefix).length == 0) {\n      _pairedPrefix = defaultPrefix;\n    }\n    address _pairedToken = pairedToken[_vaultToken];\n    if (_pairedToken == address(0)) {\n      _pairedToken = defaultPairedToken;\n    }\n\n    string memory symbol1 = IERC20Metadata(_vaultToken).symbol();\n    string memory symbol2 = IERC20Metadata(_pairedToken).symbol();\n    return string(abi.encodePacked(_pairedPrefix, symbol1, symbol2));\n  }\n\n  function pairForVaultToken(address _vaultToken, address _pairedToken) external view override returns (address) {\n    return _pairFor(uniLikeExchange, _vaultToken, _pairedToken);\n  }\n\n  function setDefaultPairedToken(address _defaultPairedToken, string calldata _defaultPrefix) external override onlyOwner {\n    emit DefaultPairedTokenUpdated(defaultPairedToken, _defaultPairedToken);\n    defaultPairedToken = _defaultPairedToken;\n    defaultPrefix = _defaultPrefix;\n  }\n\n  function setPairedTokenForVaultToken(address _vaultToken, address _newPairedToken, string calldata _newPrefix) external override onlyOwner {\n    if (_newPairedToken == address(0)) revert ZeroAddress();\n    emit PairedTokenForVaultUpdated(_vaultToken, pairedToken[_vaultToken], _newPairedToken);\n    pairedToken[_vaultToken] = _newPairedToken;\n    pairedPrefix[_vaultToken] = _newPrefix;\n  }\n\n  function stakingTokenForVaultToken(address _vaultToken) external view override returns (address) {\n    address _pairedToken = pairedToken[_vaultToken];\n    if (_pairedToken == address(0)) {\n      _pairedToken = defaultPairedToken;\n    }\n    return _pairFor(uniLikeExchange, _vaultToken, _pairedToken);\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function _pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n      (address token0, address token1) = _sortTokens(tokenA, tokenB);\n      pair = address(uint160(uint256(keccak256(abi.encodePacked(\n              hex'ff',\n              factory,\n              keccak256(abi.encodePacked(token0, token1)),\n              hex'754e1d90e536e4c1df81b7f030f47b4ca80c87120e145c294f098c83a6cb5ace' // init code hash\n      )))));\n  }\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function _sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n      if (tokenA == tokenB) revert IdenticalAddress();\n      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n      if (token0 == address(0)) revert ZeroAddress();\n  }\n}"
    },
    "src/contracts/proxy/AdminUpgradeabilityProxy.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"./UpgradeabilityProxy.sol\";\n\n/**\n * @title BaseAdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract AdminUpgradeabilityProxy is UpgradeabilityProxy {\n  /**\n   * @dev Emitted when the administration has been transferred.\n   * @param previousAdmin Address of the previous admin.\n   * @param newAdmin Address of the new admin.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n\n  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /**\n   * Contract constructor.\n   * @param _logic address of the initial implementation.\n   * @param _adm Address of the proxy administrator.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, address _adm, bytes memory _data) payable UpgradeabilityProxy(_logic, _data) {\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n    _setAdmin(_adm);\n  }\n\n  /**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, it will delegate the call\n   * to the implementation.\n   */\n  modifier ifAdmin() {\n    if (msg.sender == _admin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  /**\n   * @return The address of the proxy admin.\n   */\n  function admin() external ifAdmin returns (address) {\n    return _admin();\n  }\n\n  /**\n   * @return The address of the implementation.\n   */\n  function implementation() external ifAdmin returns (address) {\n    return _implementation();\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   * Only the current admin can call this function.\n   * @param newAdmin Address to transfer proxy administration to.\n   */\n  function changeAdmin(address newAdmin) external ifAdmin {\n    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n    emit AdminChanged(_admin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy.\n   * Only the admin can call this function.\n   * @param newImplementation Address of the new implementation.\n   */\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeTo(newImplementation);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * This is useful to initialize the proxied contract.\n   * @param newImplementation Address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\n    _upgradeTo(newImplementation);\n    (bool success,) = newImplementation.delegatecall(data);\n    require(success);\n  }\n\n  /**\n   * @return adm The admin slot.\n   */\n  function _admin() internal view returns (address adm) {\n    bytes32 slot = ADMIN_SLOT;\n    assembly {\n      adm := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the address of the proxy admin.\n   * @param newAdmin Address of the new proxy admin.\n   */\n  function _setAdmin(address newAdmin) internal {\n    bytes32 slot = ADMIN_SLOT;\n\n    assembly {\n      sstore(slot, newAdmin)\n    }\n  }\n\n  /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal override {\n    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n    super._willFallback();\n  }\n}"
    },
    "src/contracts/proxy/IMultiProxyController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IMultiProxyController {\n    function deployerUpdateProxy(bytes32 key, address proxy) external;\n}"
    },
    "src/contracts/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IOwnable {    \n    function transferOwnership(address newOwner) external;\n}"
    },
    "src/contracts/proxy/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./IBeacon.sol\";\nimport \"./Proxy.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy {\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 private constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.beacon\")) - 1));\n        _setBeacon(beacon, data);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address beacon) {\n        bytes32 slot = _BEACON_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            beacon := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_beacon()).childImplementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        require(\n            Address.isContract(beacon),\n            \"BeaconProxy: beacon is not a contract\"\n        );\n        require(\n            Address.isContract(IBeacon(beacon).childImplementation()),\n            \"BeaconProxy: beacon implementation is not a contract\"\n        );\n        bytes32 slot = _BEACON_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, beacon)\n        }\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(_implementation(), data, \"BeaconProxy: function call failed\");\n        }\n    }\n}"
    },
    "src/contracts/proxy/BeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./IBeacon.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract BeaconUpgradeable is OwnableUpgradeable, IBeacon {\n    address private _childImplementation;\n\n    /**\n     * @dev Emitted when the child implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed childImplementation);\n\n    function __BeaconUpgradeable__init(address childImplementation_) public initializer {\n        _setChildImplementation(childImplementation_);\n    }\n\n    /**\n     * @dev Returns the current child implementation address.\n     */\n    function childImplementation() public view virtual override returns (address) {\n        return _childImplementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newChildImplementation` must be a contract.\n     */\n    function upgradeChildTo(address newChildImplementation) external virtual override onlyOwner {\n        _setChildImplementation(newChildImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newChildImplementation` must be a contract.\n     */\n    function _setChildImplementation(address newChildImplementation) private {\n        require(Address.isContract(newChildImplementation), \"UpgradeableBeacon: child implementation is not a contract\");\n        _childImplementation = newChildImplementation;\n        emit Upgraded(newChildImplementation);\n    }\n}"
    },
    "src/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n    * @dev Function that is run as the first thing in the fallback function.\n    * Can be redefined in derived contracts to add functionality.\n    * Redefinitions must call super._willFallback().\n    */\n    function _willFallback() internal virtual {\n    }\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "src/contracts/IFO.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport \"./interfaces/IFNFT.sol\";\nimport \"./interfaces/IFNFTSingle.sol\";\nimport \"./interfaces/IIFO.sol\";\nimport \"./interfaces/IIFOFactory.sol\";\n\nimport {console} from \"../test/utils/console.sol\";\n\ncontract IFO is IIFO, Initializable {\n    mapping(address => UserInfo) public override userInfo;\n    mapping(address => bool) public override whitelisted; // True if user is whitelisted\n\n    IIFOFactory public override factory;\n    IFNFT public override fnft; // FNFT the ifo contract sells\n    address public override curator;\n\n    bool public override allowWhitelisting; // whether the ifo operates through WL\n    bool public override started; // true when sale is started\n    bool public override ended; // true when sale is ended\n    bool public override paused; // circuit breaker\n\n    uint256 public override amountForSale; // amount of FNFT for sale\n    uint256 public override cap; // cap per user\n    uint256 public override duration; // ifo duration\n    uint256 public override lockedSupply;\n    uint256 public override pauseBlock; // block paused\n    uint256 public override price; // initial price per FNFT\n    uint256 public override profitRaised;\n    uint256 public override startBlock; // block started\n    uint256 public override totalRaised; // total ETH raised by sale\n    uint256 public override totalSold; // total FNFT sold by sale\n\n    /// @param _curator original owner\n    /// @param _fnftAddress FNFT address\n    /// @param _amountForSale Amount of FNFT for sale in IFO\n    /// @param _price Price per FNFT in IFO\n    /// @param _cap Maximum an account can buy\n    /// @param _duration Duration of IFO. Max duration set by DAO if _duration == 0\n    /// @param _allowWhitelisting If IFO should be governed by whitelists\n    function __IFO_init(\n        address _curator,\n        address _fnftAddress,\n        uint256 _amountForSale,\n        uint256 _price,\n        uint256 _cap,\n        uint256 _duration,\n        bool _allowWhitelisting\n    ) external override initializer {\n        // set storage variables\n        if (_curator == address(0)) revert ZeroAddress();\n        if (_fnftAddress == address(0)) revert ZeroAddress();\n        IFNFT _fnft = IFNFT(_fnftAddress);\n        uint256 curatorSupply = _fnft.balanceOf(_curator);\n        uint256 totalSupply = _fnft.totalSupply();\n        IIFOFactory _factory = IIFOFactory(msg.sender);\n        // make sure curator holds 100% of the FNFT before IFO (May change if DAO takes fee on fractionalize)\n        if (IERC165(_fnftAddress).supportsInterface(type(IFNFTSingle).interfaceId)) {\n            // reject if MC of IFO greater than reserve price set by curator. Protects the initial investors\n            //if the requested price of the tokens here is greater than the implied value of each token from the initial reserve, revert\n            if (curatorSupply < totalSupply) revert NotEnoughSupply();\n            if (_price * totalSupply / (10 ** _fnft.decimals()) > IFNFTSingle(_fnftAddress).initialReserve()) revert InvalidReservePrice();\n        } else {\n            //0.5 ether is the maximum (50%) mint fee for collection.\n            if (totalSupply == 0 || curatorSupply < totalSupply / 2) revert NotEnoughSupply();\n        }\n        // make sure amount for sale is not bigger than the supply if FNFT\n        if (_amountForSale == 0 || _amountForSale > curatorSupply) revert InvalidAmountForSale();\n        if (_cap == 0 || _cap > totalSupply) revert InvalidCap();\n        // expect ifo duration to be between minimum and maximum durations set by the DAO\n        if (_duration != 0 &&\n        (_duration < _factory.minimumDuration()\n        || _duration > _factory.maximumDuration())) revert InvalidDuration();\n\n        factory = _factory;\n        curator = _curator;\n        amountForSale = _amountForSale;\n        price = _price;\n        cap = _cap;\n        allowWhitelisting = _allowWhitelisting;\n        duration = _duration;\n        fnft = _fnft;\n\n        /// @notice approve FNFT usage by creator utility contract, to deploy LP pool or stake if IFOLock enabled\n        address creatorUtilityContract = IIFOFactory(msg.sender).creatorUtilityContract();\n        if (creatorUtilityContract != address(0)) {\n            _fnft.approve(creatorUtilityContract, totalSupply);\n        }\n    }\n\n    /// @notice checks if whitelist period is over and ends whitelist\n    modifier checkDeadline() {\n        if (block.number > startBlock + duration && duration != 0 && !ended) {\n            end();\n        }\n        _;\n    }\n\n    /// @notice modifer to check if contract is paused\n    modifier checkPaused() {\n        if (paused) revert ContractPaused();\n        _;\n    }\n\n    modifier onlyCurator() {\n        if (msg.sender != curator) revert NotCurator();\n        _;\n    }\n\n    modifier onlyGov() {\n        if (msg.sender != OwnableUpgradeable(address(factory)).owner()) revert NotGov();\n        _;\n    }\n\n    /// @notice modifer to check if contract accepts whitelists\n    modifier whitelistingAllowed() {\n        if (!allowWhitelisting) revert WhitelistingDisallowed();\n        _;\n    }\n\n    /**\n     *  @notice adds multiple whitelist to the sale\n     *  @param _addresses: dynamic array of addresses to whitelist\n     */\n    function addMultipleWhitelists(address[] calldata _addresses) external override onlyCurator whitelistingAllowed {\n        if (_addresses.length > 333) revert TooManyWhitelists();\n        for (uint256 i; i < _addresses.length;) {\n            whitelisted[_addresses[i]] = true;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     *  @notice adds a single whitelist to the sale\n     *  @param _address: address to whitelist\n     */\n    function addWhitelist(address _address) external override onlyCurator whitelistingAllowed {\n        whitelisted[_address] = true;\n    }\n\n    /// @notice withdraws FNFT from sale only after IFO. Can only withdraw after NFT redemption if IFOLock enabled\n    function adminWithdrawFNFT() external override checkDeadline onlyCurator {\n        if (!ended) revert SaleActive();\n        IFNFT _fnft = fnft;\n        if (IERC165(address(_fnft)).supportsInterface(type(IFNFTSingle).interfaceId) &&\n            IFNFTSingle(address(_fnft)).auctionState() != IFNFTSingle.State.Ended && _fnftLocked()) {\n            revert FNFTLocked();\n        }\n\n        uint256 balance = _fnft.balanceOf(address(this));\n        lockedSupply -= balance;\n        _fnft.transfer(msg.sender, balance);\n\n        emit AdminFNFTWithdrawn(address(_fnft), balance);\n    }\n\n    /// @notice withdraws ETH from sale only after IFO over\n    function adminWithdrawProfit() external override checkDeadline onlyCurator {\n        if (!ended) revert SaleActive();\n        if (profitRaised == 0) revert NoProfit();\n        uint256 profit = profitRaised;\n        profitRaised = 0;\n\n        _safeTransferETH(msg.sender, profit);\n\n        emit AdminProfitWithdrawn(address(fnft), profit);\n    }\n\n    /// @notice approve FNFT usage by creator utility contract, to deploy LP pool or stake if IFOLock enabled\n    function approve() external override onlyCurator {\n        address creatorUtilityContract = factory.creatorUtilityContract();\n        if (creatorUtilityContract == address(0)) revert ZeroAddress();\n        IFNFT _fnft = fnft;\n        _fnft.approve(creatorUtilityContract, _fnft.totalSupply());\n    }\n\n    /// @notice it deposits ETH for the sale\n    function deposit() external payable override checkPaused checkDeadline {\n        if (!started) revert SaleUnstarted();\n        if (ended) revert SaleAlreadyEnded();\n        if (allowWhitelisting) {\n            if (!whitelisted[msg.sender]) revert NotWhitelisted();\n        }\n\n        UserInfo storage user = userInfo[msg.sender];\n\n        IFNFT _fnft = fnft;\n\n        // FNFT to mint for msg.value\n        uint256 payout = msg.value * (10 ** _fnft.decimals()) / price;\n\n        if (user.amount + payout > cap) revert OverLimit();\n\n        totalSold += payout;\n\n        IIFOFactory _factory = factory;\n        address govAddress = _factory.feeReceiver();\n        uint256 govFee = _factory.governanceFee();\n\n        uint256 fee = (govFee * msg.value) / 10000;\n        uint256 profit = msg.value - fee;\n\n        user.amount += payout;\n        totalRaised += msg.value;\n        profitRaised += profit;\n\n        _fnft.transfer(msg.sender, payout);\n        _safeTransferETH(govAddress, fee);\n\n        emit FNFTSold(msg.sender, msg.value, payout);\n    }\n\n    function emergencyWithdrawFNFT() external override onlyGov {\n        IFNFT _fnft = fnft;\n        uint256 balance = _fnft.balanceOf(address(this));\n        lockedSupply = 0;\n        _fnft.transfer(curator, balance);\n\n        emit EmergencyFNFTWithdrawn(address(_fnft), balance);\n    }\n\n    /// @notice Ends the sale\n    function end() public override onlyCurator checkPaused {\n        if (!started) revert SaleUnstarted();\n        if (\n            block.number <= startBlock + duration || // If not past duration\n            block.number - startBlock < factory.minimumDuration() // If tries to end before minimum duration\n        ) revert DeadlineActive();\n        if (ended) revert SaleAlreadyEnded();\n\n        ended = true;\n        lockedSupply = fnft.balanceOf(address(this));\n        emit SaleEnded();\n    }\n\n    function fnftLocked() external view override returns(bool) {\n        return _fnftLocked();\n    }\n\n    /** @notice it checks a users ETH allocation remaining\n    *   @param _user: user's remaining allocation based on cap\n    */\n    function getUserRemainingAllocation(address _user) external view override returns (uint256) {\n        UserInfo memory user = userInfo[_user];\n        return cap - user.amount;\n    }\n\n    /**\n     *  @notice removes a single whitelist from the sale\n     *  @param _address: address to remove from whitelist\n     */\n    function removeWhitelist(address _address) external override onlyCurator whitelistingAllowed {\n        whitelisted[_address] = false;\n    }\n\n    /// @notice Starts the sale and checks if all FNFT is in IFO\n    function start() external override onlyCurator {\n        if (started) revert SaleAlreadyStarted();\n        if (ended) revert SaleAlreadyEnded();\n\n        IFNFT _fnft = fnft;\n        uint256 ifoFNFTBalance = _fnft.balanceOf(address(this));\n        uint256 totalSupply = _fnft.totalSupply();\n        // make sure curator holds 100% of the FNFT before IFO (May change if DAO takes fee on fractionalize)\n        if (IERC165(address(_fnft)).supportsInterface(type(IFNFTSingle).interfaceId)) {\n            // reject if MC of IFO greater than reserve price set by curator. Protects the initial investors\n            //if the requested price of the tokens here is greater than the implied value of each token from the initial reserve, revert\n            if (ifoFNFTBalance < totalSupply) revert NotEnoughSupply();\n        } else {\n            //0.5 ether is the maximum (50%) mint fee for collection.\n            if (totalSupply == 0 || ifoFNFTBalance < totalSupply / 2) revert NotEnoughSupply();\n        }\n        startBlock = block.number;\n        started = true;\n        emit SaleStarted();\n    }\n\n    //TODO: Add a circute breaker controlled by the DAO\n\n    /// @notice lets owner pause contract. Pushes back the IFO end date\n    function togglePause() external override onlyCurator checkDeadline returns (bool) {\n        if (!started) revert SaleUnstarted();\n        if (ended) revert SaleAlreadyEnded();\n\n        if (paused) {\n            duration += block.number - pauseBlock;\n            paused = false;\n        } else {\n            pauseBlock = block.number;\n            paused = true;\n        }\n        emit PausedToggled(paused);\n        return paused;\n    }\n    /** @notice If wrong FNFT\n    *   @param _address: address of FNFT\n    */\n    function updateFNFTAddress(address _address) external override onlyGov {\n        if (_address == address(0)) revert ZeroAddress();\n        fnft = IFNFT(_address);\n    }\n\n    function _fnftLocked() internal view returns(bool) {\n        return factory.creatorIFOLock();\n    }\n\n    /** @notice transfer ETH using call\n    *   @param _to: address to transfer ETH to\n    *   @param _value: amount of ETH to transfer\n    */\n    function _safeTransferETH(address _to, uint256 _value) private {\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        if (!success) revert TxFailed();\n    }\n}\n"
    },
    "src/test/utils/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/contracts/proxy/Create2BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./IBeacon.sol\";\nimport \"./Proxy.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\n * Slightly modified to allow using beacon proxies with Create2.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract Create2BeaconProxy is Proxy {\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 private constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor() payable {\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.beacon\")) - 1));\n        _setBeacon(msg.sender, \"\");\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address beacon) {\n        bytes32 slot = _BEACON_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            beacon := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_beacon()).childImplementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        require(\n            Address.isContract(beacon),\n            \"BeaconProxy: beacon is not a contract\"\n        );\n        require(\n            Address.isContract(IBeacon(beacon).childImplementation()),\n            \"BeaconProxy: beacon implementation is not a contract\"\n        );\n        bytes32 slot = _BEACON_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, beacon)\n        }\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(_implementation(), data, \"BeaconProxy: function call failed\");\n        }\n    }\n}"
    },
    "src/contracts/token/FNFTStakingXTokenUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./ERC20Upgradeable.sol\";\n\n// XTokens let you come in with some vault tokens, and leave with more! The longer you stay, the more vault tokens you get.\n//\n// This contract handles swapping to and from xSushi, SushiSwap's staking token.\ncontract FNFTStakingXTokenUpgradeable is OwnableUpgradeable, ERC20Upgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint256 internal constant MAX_TIMELOCK = 2592000;\n    IERC20Upgradeable public baseToken;\n\n    mapping(address => uint256) internal timelock;\n\n    event Timelocked(address user, uint256 until);\n\n    error LockTooLong();\n    error UserIsLocked();\n\n    function __FNFTStakingXToken_init(address _baseToken, string memory name, string memory symbol) public initializer {\n        __Ownable_init();\n        __ERC20_init(name, symbol);\n        baseToken = IERC20Upgradeable(_baseToken);\n    }\n\n    function burnXTokens(address who, uint256 _share) external onlyOwner returns (uint256) {\n        // Gets the amount of xToken in existence\n        uint256 totalShares = totalSupply();\n        // Calculates the amount of base tokens the xToken is worth\n        uint256 what = (_share * baseToken.balanceOf(address(this))) / totalShares;\n        _burn(who, _share);\n        baseToken.safeTransfer(who, what);\n        return what;\n    }\n\n    // Needs to be called BEFORE new base tokens are deposited.\n    function mintXTokens(address account, uint256 _amount, uint256 timelockLength) external onlyOwner returns (uint256) {\n        // Gets the amount of Base Token locked in the contract\n        uint256 totalBaseToken = baseToken.balanceOf(address(this));\n        // Gets the amount of xTokens in existence\n        uint256 totalShares = totalSupply();\n        // If no xTokens exist, mint it 1:1 to the amount put in\n        if (totalShares == 0 || totalBaseToken == 0) {\n            _timelockMint(account, _amount, timelockLength);\n            return _amount;\n        }\n        // Calculate and mint the amount of xTokens the base tokens are worth. The ratio will change overtime, as xTokens are burned/minted and base tokens deposited + gained from fees / withdrawn.\n        else {\n            uint256 what = (_amount * totalShares) / totalBaseToken;\n            _timelockMint(account, what, timelockLength);\n            return what;\n        }\n    }\n\n    function timelockUntil(address account) external view returns (uint256) {\n        return timelock[account];\n    }\n\n    function timelockAccount(address account, uint256 timelockLength) public onlyOwner {\n        if (timelockLength >= MAX_TIMELOCK) revert LockTooLong();\n        uint256 timelockFinish = block.timestamp + timelockLength;\n        if (timelockFinish > timelock[account]) {\n            timelock[account] = timelockFinish;\n            emit Timelocked(account, timelockFinish);\n        }\n    }\n\n    function _burn(address who, uint256 amount) internal override {\n        if (timelock[who] >= block.timestamp) revert UserIsLocked();\n        super._burn(who, amount);\n    }\n\n    function _timelockMint(address account, uint256 amount, uint256 timelockLength) internal {\n        timelockAccount(account, timelockLength);\n        _mint(account, amount);\n    }\n\n    function _transfer(address from, address to, uint256 value) internal override {\n        if (timelock[from] >= block.timestamp) revert UserIsLocked();\n        super._transfer(from, to, value);\n    }\n}"
    },
    "src/contracts/proxy/UpgradeabilityProxy.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"./Proxy.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title UpgradabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract UpgradeabilityProxy is Proxy {\n  /**\n   * @dev Emitted when the implementation is upgraded.\n   * @param implementation Address of the new implementation.\n   */\n  event Upgraded(address indexed implementation);\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev Contract constructor.\n   * @param _logic Address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, bytes memory _data) payable {\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }  \n\n  /**\n   * @dev Returns the current implementation.\n   * @return impl Address of the current implementation\n   */\n  function _implementation() internal override view returns (address impl) {\n    bytes32 slot = IMPLEMENTATION_SLOT;\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Upgrades the proxy to a new implementation.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Sets the implementation address of the proxy.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _setImplementation(address newImplementation) internal {\n    require(Address.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "src/contracts/mocks/NFT.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract SimpleMockNFT is ERC721, Ownable {\n    using Counters for Counters.Counter;\n\n    Counters.Counter private _tokenIdCounter;\n\n    constructor() ERC721(\"TestName\", \"TEST\") {\n        _tokenIdCounter.increment();\n    }\n\n    function mint(address _to, uint256 _id) external {\n        _mint(_to, _id);\n    }\n}\n\ncontract StandardMockNFT is ERC721, Ownable {\n\n    using Counters for Counters.Counter;\n\n    Counters.Counter private _tokenIdCounter;\n\n    string private baseURI;\n\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) {\n        _tokenIdCounter.increment();\n    }\n\n    function mint(address _to, uint256 _id) external {\n        _mint(_to, _id);\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory _newBaseURI) public onlyOwner {\n        baseURI = _newBaseURI;\n    }\n}\n\ncontract NoURIMockNFT is Ownable {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        address owner = NoURIMockNFT.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    function mint(address _to, uint256 _id) external {\n        _mint(_to, _id);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = NoURIMockNFT.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = NoURIMockNFT.ownerOf(tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(NoURIMockNFT.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(NoURIMockNFT.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n}"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "src/contracts/proxy/MultiProxyController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/IAdminUpgradeabilityProxy.sol\";\n\ncontract MultiProxyController is Ownable {\n    struct Proxy {\n        bytes32 name;\n        IAdminUpgradeabilityProxy proxy;\n        uint index;\n        bool isValue;\n    }\n\n    mapping(bytes32 => Proxy) public proxyMap;\n    bytes32[] public proxyKeys;\n\n    address public deployer;\n\n    event ProxyUpdated(bytes32 key, address proxy);\n    event ProxyRemoved(bytes32 key);\n    event ProxyAdminChanged(bytes32 key, address newAdmin);\n\n    constructor(bytes32[] memory _keys, address[] memory _proxies, address _deployer) Ownable() {\n        deployer = _deployer;\n        uint256 length = _proxies.length;\n        require(_keys.length == length, \"Not equal length\");\n        for (uint256 i; i < length;) {\n            addProxy(_keys[i], _proxies[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // Proxy Gov\n\n    function upgradeProxyTo(bytes32 key, address newImpl) public onlyOwner {\n        require(proxyMap[key].isValue, \"Doesn't exist\");\n        proxyMap[key].proxy.upgradeTo(newImpl);\n    }\n\n    function changeProxyAdmin(bytes32 key, address newAdmin) public onlyOwner {\n        require(proxyMap[key].isValue, \"Doesn't exist\");\n        proxyMap[key].proxy.changeAdmin(newAdmin);\n        emit ProxyAdminChanged(key, newAdmin);\n    }\n\n    // MultiProxyController Gov\n\n    function changeDeployer(address _deployer) external onlyOwner {\n        deployer = _deployer;\n    }\n\n    function deployerUpdateProxy(bytes32 key, address proxy) public {\n        require(msg.sender == deployer, \"Not deployer\");\n        if (proxyMap[key].isValue) {\n            _changeProxy(key, proxy);\n        } else {\n            _addProxy(key, proxy);\n        }\n    }\n\n    function _changeProxy(bytes32 key, address proxyAddress) private {\n        require(proxyMap[key].isValue, \"Doesn't exist\");\n\n        proxyMap[key].proxy = IAdminUpgradeabilityProxy(proxyAddress);\n    }\n\n    function changeProxy(bytes32 key, address proxyAddress) public onlyOwner {\n        _changeProxy(key, proxyAddress);\n    }\n\n    function changeProxyKey(bytes32 oldKey, bytes32 newKey) public onlyOwner {\n        require(proxyMap[oldKey].isValue, \"Doesn't exist\");\n\n        Proxy memory proxy = proxyMap[oldKey];\n\n        proxyMap[newKey] = proxy;\n        proxyKeys[proxy.index] = newKey;\n        delete proxyMap[oldKey];\n    }\n\n    function _addProxy(bytes32 key, address proxyAddress) private {\n        require(!proxyMap[key].isValue, \"Exists\");\n\n        IAdminUpgradeabilityProxy proxyContract = IAdminUpgradeabilityProxy(proxyAddress);\n        proxyKeys.push(key);\n        Proxy memory newProxy = Proxy(key, proxyContract, proxyKeys.length - 1, true);\n        proxyMap[key] = newProxy;\n        emit ProxyUpdated(key, proxyAddress);\n    }\n\n    function addProxy(bytes32 key, address proxyAddress) public onlyOwner {\n        _addProxy(key, proxyAddress);\n    }\n\n    function removeProxy(bytes32 key) public onlyOwner {\n        require(proxyMap[key].isValue, \"Doesn't exist\");\n        bytes32[] storage keys = proxyKeys;\n        Proxy memory proxy = proxyMap[key];\n\n        proxyMap[keys[keys.length - 1]].index = proxy.index;\n\n        keys[proxy.index] = keys[keys.length - 1];\n        keys.pop();\n\n        delete proxyMap[key];\n\n        emit ProxyRemoved(key);\n    }\n\n    function getName(bytes32 key) public view returns (bytes32) {\n        return proxyMap[key].name;\n    }\n\n    function getAdmin(bytes32 key) public view returns (address) {\n        return proxyMap[key].proxy.admin();\n    }\n\n    function getImpl(bytes32 key) public view returns(address) {\n        return proxyMap[key].proxy.implementation();\n    }\n\n    // Bulk\n\n    function changeAllAdmins(address newAdmin) external onlyOwner {\n        uint256 length = proxyKeys.length;\n        for (uint256 i; i < length;) {\n            changeProxyAdmin(proxyKeys[i], newAdmin);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function getAllProxiesInfo() public view returns (bytes32[] memory) {\n        uint256 length = proxyKeys.length;\n        bytes32[] memory proxyInfos = new bytes32[](length);\n        for (uint256 i; i < length;) {\n            proxyInfos[i] = proxyKeys[i];\n            unchecked {\n                ++i;\n            }\n        }\n        return proxyInfos;\n    }\n\n    function getAllProxies() external view returns (address[] memory) {\n        uint256 length = proxyKeys.length;\n        address[] memory proxyInfos = new address[](length);\n        for (uint256 i; i < length;) {\n            proxyInfos[i] = address(proxyMap[proxyKeys[i]].proxy);\n            unchecked {\n                ++i;\n            }\n        }\n        return proxyInfos;\n    }\n\n    function getAllImpls() external view returns (address[] memory) {\n        uint256 length = proxyKeys.length;\n        address[] memory proxyInfos = new address[](length);\n        for (uint256 i; i < length;) {\n            proxyInfos[i] = address(proxyMap[proxyKeys[i]].proxy.implementation());\n            unchecked {\n                ++i;\n            }\n        }\n        return proxyInfos;\n    }\n}\n"
    },
    "src/contracts/interfaces/IAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IAdminUpgradeabilityProxy {\n    // Read functions.\n    function admin() external view returns (address);\n\n    function implementation() external view returns (address);\n\n    // Write functions.\n    function changeAdmin(address newAdmin) external;\n\n    function upgradeTo(address newImplementation) external;\n}"
    },
    "src/contracts/mocks/ERC1155.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Mock1155 is ERC1155 {\n    constructor() ERC1155(\"https://renaissancelab.art/token/\") {\n    }\n\n    function mint(address _to, uint256 _id, uint256 _amount) external {\n        _mint(_to, _id, _amount, \"\");\n    }\n}"
    },
    "src/contracts/mocks/WETH.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @notice An implementation of Wrapped Ether. \n/// @author Anderson Singh. \ncontract WETH is ERC20 {\n\n    constructor(uint256 _wethAmount) ERC20(\"Wrapped Ether\", \"WETH\") {\n        _mint(msg.sender, _wethAmount);\n    }\n\n    /// @dev mint tokens for sender based on amount of ether sent. \n    function deposit() external payable {\n        _mint(msg.sender, msg.value);\n    }\n\n    /// @dev withdraw ether based on requested amount and user balance. \n    function withdraw(uint _amount) external {\n        require(balanceOf(msg.sender) >= _amount, \"insufficient balance.\");\n        _burn(msg.sender, _amount);\n        payable(msg.sender).transfer(_amount);\n    }\n}"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "src/contracts/mocks/ERC20.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\ncontract MockERC20Upgradeable is ERC20Upgradeable {\n    function __MockERC20Upgradeable_init(string calldata _name, string calldata _symbol) external initializer {\n        __ERC20_init(_name, _symbol);\n    }\n\n    function mint(address to, uint256 amount) external payable {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) external payable {\n        _burn(from, amount);\n    }\n}"
    },
    "src/contracts/libraries/UniswapV2Library.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"../interfaces/IUniswapV2Pair.sol\";\nimport \"./math/SafeMath.sol\";\n\nlibrary UniswapV2Library {\n    using SafeMath for uint256;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n                uint160(\n                    uint256(\n                        keccak256(\n                            abi.encodePacked(\n                                hex\"ff\",\n                                factory,\n                                keccak256(abi.encodePacked(token0, token1)),\n                                hex\"754e1d90e536e4c1df81b7f030f47b4ca80c87120e145c294f098c83a6cb5ace\" // init code hash\n                            )\n                        )\n                    )\n                )\n        );\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n        require(reserveA > 0 && reserveB > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        uint256 amountIn,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address factory,\n        uint256 amountOut,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}